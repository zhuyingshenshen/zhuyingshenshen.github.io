[{"title":"「城⻝记」-基于redis的本地⽣活点评系统","url":"/2025/10/21/chengshiji/","content":"\n# 城食记 (ChengShiJi)：Redis 在高并发场景下的 6 大核心应用实战\n\n> **项目背景**：「城食记」是我在深入学习 Java 高并发编程后，设计并实现的一个本地生活服务平台（类似大众点评 / 美团）。在开发过程中，为了解决高并发下的热点数据查询、库存超卖、用户状态管理等问题，我将 Redis 的应用深度融入到了业务架构中。\n\n------\n\n## 用户登录与状态管理：基于 Token 的分布式 Session\n\n在单体应用中，我们习惯用 `HttpSession` 存储用户状态。但在「城食记」的设计中，为了支持分布式部署和水平扩展，我采用了 **Redis + Token** 的无状态登录方案。\n\n### 核心流程\n\n1. **发送验证码**：用户输入手机号，后端生成验证码存入 Redis（Key: `login:code:{phone}`），设置 5 分钟过期。\n\n2. 登录校验：\n\n   - 校验手机号和 Redis 中的验证码。\n- 若用户不存在则自动注册。\n   - 生成 **UUID** 作为 Token。\n   - 将用户信息（UserDTO）转为 Hash 结构存入 Redis（Key: `login:token:{token}`），设置 30 分钟过期。\n   \n   \n\n3. 状态保持：\n\n   - 前端获取 Token 后存储在 LocalStorage，并在后续请求头（Header）中携带。\n   - 后端通过拦截器（Interceptor）解析 Header 中的 Token，从 Redis 获取用户信息并存入 `ThreadLocal`，供后续业务使用。\n   \n   \n\n### 技术亮点\n\n- **无状态设计**：服务端不保存用户状态，完全依赖 Redis，易于水平扩展。\n- **安全性**：Token 设置过期时间，即使泄露也有有效期限制。\n\n------\n\n## 店铺缓存：解决三大缓存问题\n\n店铺详情页是「城食记」的高频访问场景，直接查询数据库压力巨大。我在项目中实现了多级缓存策略，并针对经典的缓存问题设计了对应的解决方案。\n\n### 缓存穿透 (Cache Penetration)\n\n- **问题**：黑客或恶意用户频繁请求不存在的 ID（如 `-1`），导致请求直接打穿缓存到数据库。\n\n- 我的解决方案：缓存空对象。\n\n  - 当数据库查询为空时，仍将该 Key 存入 Redis，Value 为空字符串 `\"\"`，并设置较短的过期时间（如 1 分钟）。\n  - 后续请求该 ID 会直接命中 Redis 的空值，保护数据库。\n\n  \n\n### 缓存击穿 (Cache Breakdown)\n\n- **问题**：一个热点 Key（如超级大 V 的店铺）突然过期，此时大量并发请求涌入，瞬间压垮数据库。\n\n- 我的解决方案 A：互斥锁 (Mutex Lock)\n\n  - 利用 Redis 的 `SETNX` 实现分布式锁。\n  - 只有获取到锁的线程能去查询数据库并重建缓存，其他线程等待重试。\n\n  \n\n- 我的解决方案 B：逻辑过期 (Logical Expire)\n\n   —— \n\n  项目最终采用方案\n\n  - 缓存数据不过期（TTL = -1），但在 Value 中嵌入一个过期时间字段。\n  - 线程查询时发现逻辑过期，直接返回旧数据，并开启一个独立线程（线程池）去后台重建缓存。\n  - **优点**：无锁，性能极高，不阻塞用户请求。\n\n  \n\n### 缓存雪崩 (Cache Avalanche)\n\n- **问题**：大量 Key 在同一时间过期。\n- **我的解决方案**：给缓存过期时间添加 **随机值**（Random TTL），分散过期时间点。\n\n------\n\n## 分布式锁：基于 Redis 的并发控制\n\n在秒杀、库存扣减等场景中，单机锁（Synchronized/ReentrantLock）失效，必须使用分布式锁。\n\n### 简易版分布式锁\n\n利用 `SETNX` (Set If Not Exists) 命令：\n\n```\nSET lock:key unique_id NX PX 10000\n```\n\n`NX`：不存在才设置。\n\n`PX`：自动过期时间（防止死锁）。\n\n### 完善的分布式锁 (Redisson)\n\n手写 Lua 脚本虽然可行，但维护成本高。在「城食记」中，我引入了 **Redisson** 框架，它提供了更强大的功能：\n\n- **可重入锁**：利用 Hash 记录线程 ID 和重入次数。\n- **锁续期 (WatchDog)**：如果业务执行时间超过锁的过期时间，Redisson 会自动延长锁的有效期，防止锁提前释放。\n- **公平锁**：保证请求的顺序性。\n\n------\n\n## 点赞与排行榜：ZSet 的妙用\n\n点赞功能需要支持：点赞 / 取消、按时间排序显示点赞列表、统计点赞数。\n\n### 数据结构选择\n\n我选择了 **ZSet (Sorted Set)** 来实现这一功能：\n\n- **Key**: `blog:liked:{blogId}`\n- **Value (Member)**: `userId`\n- **Score**: `System.currentTimeMillis()` (时间戳)\n\n### 核心操作\n\n- **点赞**：`ZADD`（添加用户 ID 和当前时间戳）。\n- **取消点赞**：`ZREM`（移除用户 ID）。\n- **判断是否点赞**：`ZSCORE`（返回 null 表示未点赞）。\n- **点赞排行榜**：`ZREVRANGE`（按 Score 倒序排列，即最新点赞在前）。\n- **点赞数**：`ZCARD`（获取集合元素数量）。\n\n------\n\n## 签到功能：Bitmap 位图\n\n用户签到是一个典型的 “存粹记录状态” 的场景，且数据量极大。\n\n### 为什么用 Bitmap？\n\n如果用关系型数据库存，一个用户一年 365 条记录，数据量会非常大。\n\n在「城食记」中，我使用了 **Bitmap**，用一个比特位（bit）表示一天的状态（0 未签，1 已签）。\n\n- 一年 365 天 = 365 bits ≈ **46 Bytes**。\n- 极大节省内存空间。\n\n### 核心实现\n\n- **Key**: `sign:{userId}:{yyyyMM}`\n\n- **Offset**: `dayOfMonth - 1` (当月的第几天，从 0 开始)\n\n- **签到**：`SETBIT key offset 1`\n\n- 统计连续签到天数\n\n  ：\n\n  - 使用 `BITFIELD` 命令读取当月截至今天的所有 bit 位。\n  - 返回一个十进制数字，通过位运算（`& 1` 和 `>> 1`）从后往前遍历，统计末尾连续 1 的个数。\n\n  \n\n------\n\n## 秒杀与异步下单：Stream 消息队列\n\n秒杀业务的核心挑战是高并发读写和超卖问题。\n\n### 核心流程\n\n1. **校验**：用户资格及库存预判断（Redis）。\n\n2. **扣减库存**：利用 Redis 的 `DECR` 原子操作扣减库存。\n\n3. 异步下单\n\n   ：\n\n   - 传统做法是直接操作数据库创建订单，容易造成拥堵。\n   - **优化**：将下单信息（用户 ID、商品 ID）发送到 **Redis Stream** 队列。\n   - 后台开启一个线程（消费者），从 Stream 中拉取消息，异步写入 MySQL 创建订单。\n\n   \n\n### 技术价值\n\n- **削峰填谷**：瞬间的高并发写入变成了队列的平稳消费。\n- **解耦**：秒杀服务只负责资格校验和入队，订单服务负责落库。\n\n## 项目总结\n\n通过「城食记」这个项目，我不仅仅是完成了业务功能的开发，更重要的是将 Redis 的各种数据结构和特性深度结合到了实际场景中：\n\n1. **缓存设计**不仅仅是 `set` 和 `get`，更重要的是解决一致性和异常问题（穿透、击穿、雪崩）。\n2. **数据结构选型**的重要性：String 做缓存，Hash 存对象，ZSet 做排序和计数，Bitmap 做海量状态压缩，Stream 做消息队列。\n3. **分布式思维**：在多机部署环境下，锁、Session、事务都需要特殊的处理机制。","tags":["java","项目","技术"],"categories":["java"]},{"title":"Spintboot介绍","url":"/2025/07/11/springboot/","content":"\n# SpringBoot 全面介绍\n\nSpringBoot 是由 Pivotal 团队（后归属于 VMware）基于 Spring 框架推出的**轻量级、约定优于配置**的开源框架，核心目标是**简化 Spring 应用的开发、配置、部署和运维**，让开发者能够快速搭建生产级别的 Spring 应用。\n\n## 核心定位\n\nSpringBoot 并非替代 Spring，而是对 Spring 框架的**封装和增强**：\n\n- 解决 Spring 原生开发中 “配置繁琐、依赖管理复杂、部署麻烦” 等痛点；\n- 提供 “开箱即用” 的能力，同时保留足够的灵活性（支持自定义配置）；\n- 专注于快速构建独立的、可运行的 Spring 应用（尤其是微服务场景）。\n\n## 核心特性\n\n### 约定优于配置（Convention over Configuration）\n\nSpringBoot 内置了大量默认配置规则，无需手动编写 XML 配置（如 Spring 传统的 `applicationContext.xml`），仅需少量配置（甚至零配置）即可启动应用：\n\n- 默认扫描主程序所在包及其子包的组件；\n- 默认配置数据源、日志、Web 容器（Tomcat）等核心组件；\n- 通过 `application.yml/application.properties` 即可覆盖默认配置。\n\n### 自动配置（AutoConfiguration）\n\n这是 SpringBoot 最核心的特性：\n\n- 基于项目中引入的依赖（如 `spring-boot-starter-web`），自动识别并配置相关组件（如 DispatcherServlet、Tomcat、Jackson 等）；\n- 底层通过 `@EnableAutoConfiguration` 注解结合 SPI（服务提供者接口）机制实现，开发者可通过 `@Conditional` 系列注解自定义自动配置规则；\n- 支持通过 `spring-boot-starter` 依赖 Starter 套件，一键引入场景化依赖（如 Web、数据库、缓存、消息队列等）。\n\n### 起步依赖（Starter Dependencies）\n\n将常用场景的依赖打包成统一的 Starter，避免手动管理依赖版本和依赖冲突：\n\n| 常用 Starter                   | 用途                            |\n| ------------------------------ | ------------------------------- |\n| `spring-boot-starter-web`      | Web 开发（Spring MVC + Tomcat） |\n| `spring-boot-starter-data-jpa` | 持久层（JPA + Hibernate）       |\n| `spring-boot-starter-mybatis`  | 持久层（MyBatis）               |\n| `spring-boot-starter-redis`    | Redis 缓存操作                  |\n| `spring-boot-starter-test`     | 单元测试（JUnit + Mockito）     |\n\n### 嵌入式容器\n\nSpringBoot 内置了 Tomcat（默认）、Jetty、Undertow 等 Servlet 容器，应用可直接打成 **可执行 JAR 包**，无需手动部署到外部容器：\n\n- 执行 `java -jar xxx.jar` 即可启动应用；\n- 支持通过配置修改容器端口、线程池等参数。\n\n### 监控与运维\n\n- 内置 `spring-boot-starter-actuator`，可暴露应用健康状态、指标、日志、环境变量等监控端点（如 `/actuator/health`、`/actuator/metrics`）；\n- 支持与 Prometheus、Grafana 等监控工具集成，实现可视化监控和告警；\n- 支持热部署（`spring-boot-devtools`），开发阶段无需重启应用即可生效代码修改。\n\n### 简化部署\n\n- 支持打包为可执行 JAR/WAR 包，也支持 Docker 容器化部署；\n- 与 CI/CD 工具（Jenkins、GitLab CI）无缝集成，简化持续交付流程。\n\n### 无代码生成 & 无 XML 配置\n\n完全基于注解驱动开发，无需生成额外代码，也无需编写 XML 配置文件，核心配置通过注解（如 `@SpringBootApplication`、`@RestController`）和配置文件实现。","tags":["SpringBoot"],"categories":["java"]},{"title":"java基础","url":"/2025/07/10/Javabasic/","content":"\n## Day1\n\n随便写一个整数，默认是int类型，如果将一个超过int范围的数赋值给一个long类型的变量\n\n`long l1 = 334254235555`则会报错，因为超出了int范围。正确写法是加数后面加上L或l指定类型。\n\n如果是任意写一个浮点数，则默认是double类型的，若要指定为float则加上f\n\nchar既是字符，又能当作数值运算。\n\n## Day2\n在表达式中，小范围类型的变量，会自动转换成表达式中较大范围的类型，再参与运算。\n\nbyte、short、char —> int —>long —>float —> double\n\n+ 表达式的最终结果类型由表达式中的最高类型决定。\n+ 在表达式中，**byte、short、char是直接转换成int类型参与运算的。**\n\n扩展的赋值运算符(+= -= *= /= %=)隐含了强制类型转换\n\n&&和&区别 判断结果一样,&&短路与会提前中断。\n\n||和|区别，判断结果一样，||短路或会提前中断。\n\n## Day3\nSwitch 表达式类型只能是byte、short、int、char,JDK5开始支持枚举，JDK7开始支持String,不支持double、float、long。case给出的值不能重复，且只能是字面量，不能是变量。不要忘写break。\n\n### 数组\n```java\n//静态初始化数组 定义时已确定数据\n数据类型[] 数据名 = {元素1,元素2,元素3,..。};\nint[] arr = {12,24,36};\n//完整格式\n数据类型[] 数据名 = new 数据类型[]{元素1，元素2，元素3...}\nint[] arr = new int[]{12,24,36};\n//动态初始化数组\n数据类型[] 数据名 = new 数据类型[长度]\nint[] arr = new int[3];\n```\n\n## Day4\n类默认就自带了一个无参构造器(类似C++的构造函数)\n\n为类定义了有参数构造器，那么类默认的无参数构造器就没有了，此时如果还想用无参数构造器，就必须手写一个无参数构造器\n\n类的属性前面加static,意为静态变量，类的静态变量是共用的，在内存中占一处空间，一般是用类名.属性名来使用。\n\n类的方法前面加staic,意为静态方法，静态方法可以用来设计工具类，工具类中的方法都是静态方法，每个类方法用来完成一个功能，提高代码复用性。\n\n**静态方法和实例方法的区别:**静态方法可以直接访问静态成员，但不可以访问实例成员(静态成员存储在方法区，在类加载时初始化，与类本身绑定，静态方法本身没有隐含的`this`引用，)\n\n子类对象包含父类的所有成员，因为子类实例化时回调用父类的构造函数初始化父类的成员。虽然私有变量存在于子类对象中，但是子类无法通过变量名直接操作它们(需要通过父类提供的public/protected方法访问)\n\n### 权限修饰符\nprivate 本类\n\ndefault(缺省) 本类、同一个包中的类\n\nprotected 本类，同一个包的类、子孙类中\n\npublic 任意位置\n\n## Day5\n### 重写\n@Override 重写标识符\n\n子类重写Object类的toString()方法(默认返回对象地址)，以便放回对象的内容。\n\n### this()\n默认情况下，子类全部构造器的第一行代码都是super()，它会调用父类的无参数构造器。\n\n如果父类没有无参数构造器，则我们必须要在子类构造器的第一行手写super(...),去指定调用父类的有参构造器。\n\n**super构造器或this构造器必须写在构造器的第一行 并且不能同时出现**\n\n### 多态\n多态前提:有继承/实现关系;存在父类引用子类对象；存在方法重写\n\n```plain\nPeople p1 = new Student();\np1.run();\n\nPeople p2 = new Teacher();\np2.run();\n```\n\nJava多态表现为对象多态、行为多态(方法重写)\n\n多态是对象、行为的多态， 方法:编译看左，左即左边的类 运行看右 成员变量:编译看左，运行也看左 这里的“左”指的是**引用类型**，也就是声明对象时等号左边的类型。\n\n成员变量和方法不同，它们**不具备多态性**。**无论运行时实际对象是什么类型，访问成员变量时，永远只看引用类型（左边）的成员变量。**\n\n多态下不能调子类独有功能 （编译器为了保证代码的安全性，只允许你调用左边引用类型所拥有的功能。)\n\n多态好处:右边对象解耦合，便于拓展维护。定义方法时，使用父类类型形参可以接收一切子类对象，扩展性强\n\n```plain\n遇到的问题:\n\nQ:Animal a1 = new Tortoise();\n\nTortoise t1 = a1;直接这样写为什么不行 a1难道不算Tortoise的对象吗?前面不是刚new了一遍吗\n\nTortoise t1 = (Tortoise) a1; 为什么必须像这样强制转换了才能用?\n\nA:编译器的保护机制，使得开发者必须强制类型转换告诉编译器知道a1是Tortoise类型。\n\nAnimal a1 = new Tortoise();\n\nParrot p1 = (Parrot) a1 这样写编译时不保存，但是运行时会发现试图将Tortoise类型的对象转换成Parrot,会报错ClassCastException。\n```\n\n**Java建议在强制转换前，应该判断对象的真实类型，再进行强制类型转换。**(用instanceof)\n\n## Day6\n### final关键字\nfinal修饰静态变量，这个变量今后被称为常量，常量名称建议全部大写。\n\n被final修饰的量**不能被继承**\n\n修饰基本类型变量，变量存储的**数据**不能被改变。\n\n修饰引用类型变量(数组)，变量存储的**地址**不能被改变，但地址所指对象的内容可变。\n\n### 设计模式\n单例设计模式\n\n```java\n//单例设计模式\npublic class A{\n    private static A a =new A()；\n    //私有化构造器\n    private A(){\n    \n    }\n    public static A getInstance(){\n        return a;\n    }\n}\n//懒汉式单例类 延迟加载对象\npublic class B{\n    private static B b；\n    //私有化构造器\n    private b(){\n    }\n    public static B getInstance(){\n        if(b == null){\n            b = new B();\n        }\n        return b;\n    }\n}\n```\n\n模板方法设计模式\n\n1、定义一个抽象类。\n\n2、在里面定义2个方法\n\n+ 一个是模板方法：把共同的实现步骤放里面去。\n+ 一个是抽象方法：不确定的实现步骤，交给具体的子类来完成。\n\n### 枚举类\n枚举类是final最终类不可被继承，枚举类继承java.lang.Enum类 枚举类第一行只能罗列一些常量名称，**常量回记住枚举类的一个对象。**构造器为私有，对外不能创建对象。编译器为枚举类新增了几个方法。\n\n```java\npublic enum A{\n    X,Y,Z;\n}\nComplied from \"A.java\"\npublic final class A extends java.lang.Enum<A>{\n    public static fianl A X = new A();\n    public static fianl A Y = new A();\n    public static fianl A Z = new A();\n    \n    public static A[] values();\n    public static A valueOf(java.lang.String);\n\n}\n```\n\n### 抽象类\n用abstract修饰；抽象方法只有方法签名，不能写方法体。\n\n可以不写抽象方法，但有**抽象方法的类必须是抽象类**，类有的成员，抽象类都具备。\n\n**抽象类不能创建对象**，仅作为一种特殊的父类让子类继承并实现。**抽象类的子类必须重写父类的所有抽象方法**，除非子类本身也被声明为 `abstract`\n\n### 接口\n使用interface关键字定义的一种结构，JDK8之前，接口中只能定义成员变量(常量)和成员方法(抽象方法)。\n\n`实现类`实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类。\t\n\n修饰符 class 实现类类名 implements 接口1，接口2，接口3， ...{\n\n}\n\n接口在高版本支持默认方法，私有方法private\n\n**注意事项：**\n\n+ 接口与接口可以多继承：一个接口可以同时继承多个接口[重点]\n+ 一个接口继承多个接口，如果多个接口存在方法签名冲突（方法名和参数列表相同但返回类型不同的方法)则此时不支持多继承，也不支持多实现\n+ _一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的_\n+ 一个类实现了多个接口，如果多个接口中存在同名的方法，可以不冲突，\n\n### 匿名内部类\n书写格式:\n\n```java\nnew 类或接口(参数值...){\n     类体(一般是方法重写);\n}\n\nnew Animal(){\n @Override\n public void cry(){\n }\n};\n```\n\n匿名内部类本质就是一个子类，并会立即创建出一个子类对象。\n\n匿名内部类实际上有名字(在编译后产生类文件)外部类名$编号.class\n\n**匿名类的本质是编译器自动生成一个没有名字的实现类，并直接实例化。**\n\n`public static void start(Swim s)`这里的s可以直接用下面这种方式传参\n\n```java\nstart(new Swim(){\n    @Override\n    pubic void swimming(){\n        System.out.printlin(\"游泳1\");\n    }\n});\n```\n\n使用场景一:为按钮添加事件监听器对象\n\n使用场景二:使用comparator接口的匿名内部类实现对数组排序\n\n### Lambda\nLambda表达式只能简化函数式接口的匿名内部类\n\n```java\n@FunctionalInterface // 声明函数式接口的注解 声明后只能写一个抽象方法\ninterface Swim{\n    void swimming();\n}\n\n/*Swim s1 = new Swim(){\n    @Override\n    public void swimming(){\n        System.out.println(\"学生游泳\");\n    }\n};\n*/\nSwim s1 = () - > {\n    System.out.println(\"学生游泳\");\n};\n\n\n```\n\n\n\n函数式接口:只有一个抽象方法的接口  \n`@FunctionInterface`声明函数式接口的注解\n\n\n\n#### 静态方法引用\n类名::静态方法 使用场景:Lambda表达式只调用**一个**静态方法，并且\"->\"前后参数形式一致，就可以使用静态方法引用。\n\n#### 实例方法引用\n对象名::实例方法 使用场景:如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“->”前后参数的形式一致，就可以使用实例方法引用。\n\n#### 特定方法类型引用\n特性类的名称::方法 使用场景:某个lambda表达式中只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时可以使用特定类型的方法引用。\n\n```java\nArrays.sort(names);\nArrays.sort(names,new Comparator<String>(){\n    @Override\n    public int compare(String o1,String o2){\n        //o1 a1\n        //o2 a2\n        return o1.compareToIgnoreCase(o2);\n    }\n});\nArrays.sort(names,(o1,o2) -> o1.compareToIgnoreCase(o2));\n//特定类型方法引用: 类型名称::方法名\nArrays.sort(names,String::compareToIgnoreCase);\n\nSystem.out.printlin(Arrays.toString(names));\n```\n\n\n\n#### 构造器引用\n类名::new 使用场景:如果某个lambda表达式里只是在创建对象，并且“->”前后参数情况一致，就可以使用构造器引用。\n\n### String\n创建对象封装字符串数据的方式\n\n+ 直接使用双引号“...”(会存储到字符串常量池，并且相同内容的字符串只存储一份)\n+ new String类，调用构造器初始化字符串对象(每new一次都会产生一个新的对象放到堆内存中)\n\n","tags":["java"],"categories":["java"]},{"title":"java介绍","url":"/2025/07/10/java/","content":"\n# Java 全面介绍\n\nJava 是由 Sun Microsystems（后被 Oracle 收购）于 1995 年推出的**面向对象、跨平台**的高级编程语言，由詹姆斯・高斯林（James Gosling）领衔开发，核心设计理念是 “Write Once, Run Anywhere（一次编写，到处运行）”，现已成为全球最主流的编程语言之一，广泛应用于企业级开发、移动开发、大数据、云计算等领域。\n\n## 核心定位\n\nJava 并非单一的 “编程语言”，而是一套完整的**技术生态**：\n\n- 包含编程语言规范、编译器（javac）、虚拟机（JVM）、类库（Java SE API）、开发工具（JDK）等；\n- 核心目标是实现 “跨平台” 和 “高可靠性”，兼顾开发效率与运行性能；\n- 既支持面向对象编程（OOP），也逐步兼容函数式编程（Java 8 引入 Lambda 表达式）。\n\n## 核心特性\n\n### 跨平台性（Write Once, Run Anywhere）\n\n这是 Java 最核心的特性，底层依赖 **Java 虚拟机（JVM）** 实现：\n\n- 开发者编写的 Java 代码（.java 文件）经编译器编译为**字节码文件（.class）**，而非直接编译为机器码；\n- 不同操作系统（Windows、Linux、macOS）安装对应的 JVM，JVM 负责将字节码解释 / 编译为本地机器码执行；\n- 无需针对不同系统修改代码，仅需保证目标系统有兼容的 JVM。\n\n### 面向对象（OOP）\n\nJava 严格遵循面向对象的核心思想，万物皆为 “对象”：\n\n- 封装（Encapsulation）：通过类和访问修饰符（public/private/protected）隐藏内部实现，暴露统一接口；\n- 继承（Inheritance）：通过 `extends` 实现类的复用，单继承（类）+ 多实现（接口）避免复杂继承链；\n- 多态（Polymorphism）：通过方法重写（Override）和接口实现，实现 “一个接口，多种实现”；\n- 核心关键字：`class`、`object`、`interface`、`extends`、`implements` 等。\n\n### 健壮性（Robustness）\n\nJava 设计上大幅降低出错概率，适合构建稳定的企业级应用：\n\n- 自动内存管理（垃圾回收 GC）：JVM 自动回收不再使用的内存，避免 C/C++ 中的内存泄漏、野指针问题；\n- 强类型检查：编译期严格检查类型匹配，减少运行时错误；\n- 异常处理机制：通过 `try-catch-finally` 统一处理错误，避免程序崩溃；\n- 无指针直接操作：通过引用替代指针，降低内存操作风险。\n\n### 安全性（Security）\n\nJava 最初为嵌入式设备和网络环境设计，内置多层安全防护：\n\n- 字节码验证：JVM 加载字节码时验证合法性，防止恶意代码执行；\n- 安全管理器（SecurityManager）：可限制程序的文件访问、网络连接等权限；\n- 沙箱机制：隔离不可信代码的运行环境，避免对系统造成破坏；\n- 适合开发网络应用（如电商、金融），满足数据安全要求。\n\n### 高性能（High Performance）\n\n早期 Java 因 “解释执行” 性能较弱，现已通过多项优化大幅提升：\n\n- JIT 编译器（即时编译）：JVM 运行时将高频执行的字节码编译为本地机器码，接近原生程序性能；\n- 垃圾回收优化：G1、ZGC、Shenandoah 等新一代 GC 算法，大幅降低停顿时间；\n- 支持多线程：内置线程 API（`Thread`、`Runnable`、`Callable`），充分利用多核 CPU；\n- 大数据 / 高并发场景下（如电商秒杀），Java 性能可满足生产要求。\n\n### 可移植性 & 可扩展性\n\n- 可移植性：除跨平台外，Java 类库（如 java.lang、java.util）在不同 JVM 实现中行为一致；\n- 可扩展性：通过接口、抽象类、模块化（Java 9 引入 Module）实现代码解耦，便于扩展和维护；\n- 支持分布式：内置网络编程 API（[java.net](https://java.net/)、java.nio），适配分布式系统开发。\n","tags":["java","技术"],"categories":["java"]},{"title":"局域网即时通讯软件","url":"/2025/01/26/lan-chat-system/","content":"\n\n\n# 基于 JavaSE+Socket 实现局域网即时通讯软件\n\n## 项目背景与需求\n\n在学习 Java 网络编程（Socket）和 Swing GUI 开发后，为了巩固核心知识点并理解 C/S（客户端 / 服务端）架构的通信原理，我设计并开发了这款局域网即时通讯软件。\n\n**核心需求如下：**\n\n1. **极简登录**：用户仅需输入昵称即可进入聊天室，无需复杂的账号密码验证。\n2. **群聊功能**：支持多用户实时群聊，消息需即时推送到所有在线客户端。\n3. **在线状态**：实时展示在线用户列表及人数，用户上下线时自动更新列表。\n4. **界面友好**：基于 Swing 实现可视化操作界面，包含消息展示区、输入区、发送按钮及在线列表区。\n\n## 技术选型与核心思路\n\n### 技术栈\n\n- **GUI 编程**：Swing（实现客户端可视化界面）。\n- **网络编程**：Socket + ServerSocket（基于 TCP 协议实现客户端与服务端的可靠通信）。\n- **数据存储**：HashMap（服务端用于维护在线用户与 Socket 的映射关系）。\n- **多线程**：独立线程处理客户端连接与消息读写，避免单线程阻塞导致的程序假死。\n- **协议设计**：自定义消息类型协议（区分登录、群聊、私聊消息）。\n\n### 整体架构\n\n系统采用标准的 C/S 架构，核心交互流程如下：\n\n1. **服务端**：监听端口 -> 接收客户端连接 -> 分配独立线程处理 -> 维护在线用户列表 -> 转发群聊消息。\n2. **客户端**：登录界面输入昵称 -> 建立 Socket 连接 -> 发送登录消息 -> 进入聊天界面 -> 实时接收服务端推送的在线列表 / 群聊消息。\n\n## 核心功能实现\n\n### 服务端开发\n\n#### 服务端启动与连接监听\n\n服务端的核心职责是监听指定端口，并为每个新连接的客户端分配一个独立的线程（`ServerReaderThread`）。这样可以避免单线程阻塞，支持多客户端并发通信。\n\n```java\npublic class Server {\n    // 存储在线客户端：key为Socket对象，value为用户昵称\n    public static final Map<Socket, String> onLineSockets = new HashMap<>();\n    private static final int PORT = 8888; // 监听端口\n\n    public static void main(String[] args) {\n        System.out.println(\"启动服务端系统.....\");\n        try {\n            ServerSocket serverSocket = new ServerSocket(PORT);\n            // 主线程循环接收客户端连接\n            while (true) {\n                System.out.println(\"等待客户端的连接.....\");\n                Socket socket = serverSocket.accept();\n                // 为每个客户端分配独立线程处理消息交互\n                new ServerReaderThread(socket).start();\n                System.out.println(\"一个客户端连接成功.....\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### 消息处理线程（核心逻辑）\n\n服务端线程负责循环读取客户端发送的数据流，根据自定义的协议类型（1 - 登录，2 - 群聊）执行不同的业务逻辑：\n\n- **登录消息**：将用户 Socket 和昵称存入 Map，并广播更新所有客户端的在线列表。\n- **群聊消息**：接收消息内容，拼装成 “昵称 + 时间 + 内容” 的格式，转发给所有在线客户端。\n\n```java\npublic class ServerReaderThread extends Thread {\n    private Socket socket;\n\n    public ServerReaderThread(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            DataInputStream dis = new DataInputStream(socket.getInputStream());\n            while (true) {\n                // 读取消息类型\n                int type = dis.readInt(); \n                switch (type) {\n                    case 1:\n                        // 1. 处理登录逻辑\n                        String nickname = dis.readUTF();\n                        Server.onLineSockets.put(socket, nickname);\n                        updateClientOnLineUserList(); // 广播在线列表\n                        break;\n                    case 2:\n                        // 2. 处理群聊消息转发\n                        String msg = dis.readUTF();\n                        sendMsgToAll(msg); // 群发消息\n                        break;\n                }\n            }\n        } catch (Exception e) {\n            // 客户端下线处理\n            System.out.println(\"客户端下线：\" + socket.getInetAddress().getHostAddress());\n            Server.onLineSockets.remove(socket);\n            updateClientOnLineUserList();\n        }\n    }\n\n    // 广播在线用户列表\n    private void updateClientOnLineUserList() {\n        Collection<String> names = Server.onLineSockets.values();\n        for (Socket s : Server.onLineSockets.keySet()) {\n            try {\n                DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n                dos.writeInt(1); // 标记为列表更新\n                dos.writeInt(names.size());\n                for (String name : names) dos.writeUTF(name);\n                dos.flush();\n            } catch (Exception e) { e.printStackTrace(); }\n        }\n    }\n\n    // 群发消息\n    private void sendMsgToAll(String msg) {\n        String sender = Server.onLineSockets.get(socket);\n        String time = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"HH:mm:ss\"));\n        String sendContent = sender + \" [\" + time + \"]：\\n\" + msg + \"\\n\";\n\n        for (Socket s : Server.onLineSockets.keySet()) {\n            try {\n                DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n                dos.writeInt(2); // 标记为群聊消息\n                dos.writeUTF(sendContent);\n                dos.flush();\n            } catch (Exception e) { e.printStackTrace(); }\n        }\n    }\n}\n```\n\n### 客户端开发\n\n#### 登录与连接\n\n基于 Swing 实现登录界面，用户点击 “进入” 后，程序尝试与服务端建立 Socket 连接，并发送登录协议头（1）和昵称。\n\n```java\n// 登录按钮点击事件逻辑\nenterButton.addActionListener(e -> {\n    String nickname = nicknameField.getText().trim();\n    if (nickname.isEmpty()) return;\n    try {\n        // 建立连接\n        Socket socket = new Socket(\"127.0.0.1\", 8888);\n        // 发送登录信息\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n        dos.writeInt(1); // 协议头：登录\n        dos.writeUTF(nickname);\n        dos.flush();\n        \n        // 关闭登录窗，打开聊天窗\n        dispose();\n        new ClientChatFrame(socket, nickname).setVisible(true);\n    } catch (IOException ex) {\n        JOptionPane.showMessageDialog(this, \"服务端连接失败！\");\n    }\n});\n```\n\n#### 聊天界面与消息接收\n\n聊天界面包含消息展示区（只读）、输入区和在线列表。为了防止接收消息阻塞 UI 线程，客户端同样启动了一个独立的 `ClientReaderThread` 来专门读取服务端的推送数据。\n\n```java\n// 客户端消息读取线程\nclass ClientReaderThread extends Thread {\n    private Socket socket;\n    private ClientChatFrame frame;\n\n    public ClientReaderThread(ClientChatFrame frame, Socket socket) {\n        this.frame = frame;\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            DataInputStream dis = new DataInputStream(socket.getInputStream());\n            while (true) {\n                int type = dis.readInt();\n                if (type == 1) {\n                    // 更新在线列表UI\n                    int size = dis.readInt();\n                    String[] users = new String[size];\n                    for (int i = 0; i < size; i++) users[i] = dis.readUTF();\n                    frame.onLineUsers.setListData(users);\n                } else if (type == 2) {\n                    // 追加群聊消息到文本域\n                    String msg = dis.readUTF();\n                    frame.smsContent.append(msg);\n                }\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(frame, \"您已下线！\");\n        }\n    }\n}\n```\n\n## 项目总结与扩展\n\n### 核心收获\n\n通过本次实战，我深入理解了以下核心概念：\n\n1. **TCP 通信机制**：理解了三次握手、Socket 流的阻塞特性以及如何通过 `DataInputStream/DataOutputStream` 进行结构化数据传输。\n2. **并发编程**：掌握了多线程在网络编程中的应用，特别是服务端如何利用线程池（或简单的多线程）处理高并发连接。\n3. **协议设计**：学会了在传输层之上定义简单的应用层协议（通过 int 类型区分消息体），这是构建复杂网络应用的基础。\n\n### 扩展方向\n\n目前的版本实现了基础的群聊功能，未来可以扩展以下功能：\n\n- **私聊功能**：在协议中增加私聊标记（type 3），并在服务端根据目标用户名查找对应的 Socket 进行发送。\n- **断线重连**：增加心跳检测机制，当检测到连接断开时自动尝试重连。\n- **消息持久化**：将聊天记录保存到本地文件或数据库中，支持历史记录回溯。","tags":["java","项目","技术"],"categories":["java"]},{"title":"leetcodeHot100","url":"/2024/05/23/leetcodehot/","content":"\n\n\n# Hot100\n\n## 哈希\n\n### 两数之和\n\n给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n\n你可以按任意顺序返回答案。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,7,11,15], target = 9\n输出：[0,1]\n解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,4], target = 6\n输出：[1,2]\n```\n\n**示例 3：**\n\n```\n输入：nums = [3,3], target = 6\n输出：[0,1]\n```\n\n \n\n**提示：**\n\n- `2 <= nums.length <= 104`\n- `-109 <= nums[i] <= 109`\n- `-109 <= target <= 109`\n- **只会存在一个有效答案**\n\n方法一：暴力枚举\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```\n\n方法二：哈希表\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n```\n\n### 字母异位词分组\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n \n\n**示例 1:**\n\n**输入:** strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]\n\n**输出:** [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n**解释：**\n\n- 在 strs 中没有字符串可以通过重新排列来形成 `\"bat\"`。\n- 字符串 `\"nat\"` 和 `\"tan\"` 是字母异位词，因为它们可以重新排列以形成彼此。\n- 字符串 `\"ate\"` ，`\"eat\"` 和 `\"tea\"` 是字母异位词，因为它们可以重新排列以形成彼此。\n\n**示例 2:**\n\n**输入:** strs = [\"\"]\n\n**输出:** [[\"\"]]\n\n**示例 3:**\n\n**输入:** strs = [\"a\"]\n\n**输出:** [[\"a\"]]\n\n \n\n**提示：**\n\n- `1 <= strs.length <= 104`\n- `0 <= strs[i].length <= 100`\n- `strs[i]` 仅包含小写字母\n\n```java\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> map = new HashMap<String, List<String>>();\n        for (String str : strs) {\n            char[] array = str.toCharArray();\n            Arrays.sort(array);\n            String key = new String(array);\n            List<String> list = map.getOrDefault(key, new ArrayList<String>());\n            list.add(str);\n            map.put(key, list);\n        }\n        return new ArrayList<List<String>>(map.values());\n    }\n}\n```\n\n### 最长连续序列\n\n给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [100,4,200,1,3,2]\n输出：4\n解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,3,7,2,5,8,4,6,0,1]\n输出：9\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,0,1,2]\n输出：3\n```\n\n \n\n**提示：**\n\n- `0 <= nums.length <= 105`\n- `-109 <= nums[i] <= 109`\n\n```java\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> numsset=new HashSet<>();\n        for(int num:nums){\n            numsset.add(num);\n        }\n        int res=0;\n        int count=0;\n        for(int num:numsset){\n            if(!numsset.contains(num-1)){\n                int currentNum=num;\n                count=1;\n                while(numsset.contains(currentNum+1)){\n                    count++;\n                    currentNum++;\n                }\n                res=Math.max(res,count);\n            }\n\n        }\n        return res;\n\n    }\n}\n```\n\n## 双指针\n\n### 接雨水\n\n给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)\n\n```\n输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]\n输出：6\n解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 \n```\n\n**示例 2：**\n\n```\n输入：height = [4,2,0,3,2,5]\n输出：9\n```\n\n \n\n**提示：**\n\n- `n == height.length`\n- `1 <= n <= 2 * 104`\n- `0 <= height[i] <= 105`\n\n动态规划法：\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int len=height.length;\n        int left=0,right=len-1;\n        int[] leftmax=new int[len];\n        int[] rightmax=new int[len];\n        leftmax[0]=height[0];\n        rightmax[len-1]=height[len-1];\n        for(int i=1;i<len;i++){\n            leftmax[i]=Math.max(leftmax[i-1],height[i]);\n            rightmax[len-1-i]=Math.max(rightmax[len-i],height[len-1-i]);\n        }\n        int res=0;\n        for(int i=0;i<len;i++){\n            res+=Math.min(leftmax[i],rightmax[i])-height[i];\n        }\n        return res;\n    }\n}\n```\n\n双指针法：\n\n```java\nclass Solution {\n    public int trap(int[] height) {\n        int ans = 0;\n        int left = 0, right = height.length - 1;\n        int leftMax = 0, rightMax = 0;\n        while (left < right) {\n            leftMax = Math.max(leftMax, height[left]);\n            rightMax = Math.max(rightMax, height[right]);\n            if (height[left] < height[right]) {\n                ans += leftMax - height[left];\n                ++left;\n            } else {\n                ans += rightMax - height[right];\n                --right;\n            }\n        }\n        return ans;\n    }\n}\n```\n\n### 移动零\n\n给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**示例 2:**\n\n```\n输入: nums = [0]\n输出: [0]\n```\n\n \n\n**提示**:\n\n- `1 <= nums.length <= 104`\n- `-231 <= nums[i] <= 231 - 1`\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int n = nums.length, left = 0, right = 0;\n        while (right < n) {\n            if (nums[right] != 0) {\n                swap(nums, left, right);\n                left++;\n            }\n            right++;\n        }\n    }\n\n    public void swap(int[] nums, int left, int right) {\n        int temp = nums[left];\n        nums[left] = nums[right];\n        nums[right] = temp;\n    }\n}\n```\n\n注意到以下性质：\n\n1. 左指针左边均为非零数；\n2. 右指针左边直到左指针处均为零。\n\n### 盛最多水的容器\n\n给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。\n\n找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n**说明：**你不能倾斜容器。\n\n \n\n**示例 1：**\n\n![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)\n\n```\n输入：[1,8,6,2,5,4,8,3,7]\n输出：49 \n解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n```\n\n**示例 2：**\n\n```\n输入：height = [1,1]\n输出：1\n```\n\n \n\n**提示：**\n\n- `n == height.length`\n- `2 <= n <= 105`\n- `0 <= height[i] <= 104`\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        int i = 0, j = height.length - 1, res = 0;\n        while(i < j) {\n            res = height[i] < height[j] ?\n                    Math.max(res, (j - i) * height[i++]):\n                    Math.max(res, (j - i) * height[j--]);\n        }\n        return res;\n    }\n}\n\n```\n\n### 三数之和\n\n给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。\n\n**注意：**答案中不可以包含重复的三元组。\n\n \n\n \n\n**示例 1：**\n\n```\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n```\n\n**示例 3：**\n\n```\n输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n```\n\n \n\n**提示：**\n\n- `3 <= nums.length <= 3000`\n- `-105 <= nums[i] <= 105`\n\n```java\npublic class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result=new ArrayList<>();\n        int len=nums.length;\n        Arrays.sort(nums);\n        for(int first=0;first<len-1;first++){\n            if(first>0&&nums[first]==nums[first-1]){\n                continue;\n            }\n            int third=len-1;\n            int target=-nums[first];\n            int second=first+1;\n            while(second<third){\n                if (nums[second]+nums[third]==target){\n                    List<Integer> list=new ArrayList<>();\n                    list.add(nums[first]);\n                    list.add(nums[second]);\n                    list.add(nums[third]);\n                    result.add(list);\n                    second++;\n                    third--;\n                    while(second<third && nums[second]==nums[second-1]){\n                        second++;\n                    }\n                    while(second<third && nums[third]==nums[third+1]){\n                        third--;\n                    }\n                }else{\n                    if(nums[second]+nums[third]>target){\n                        third--;\n                    }else{\n                        second++;\n                    }\n                }\n\n\n            }\n        }\n        return result;\n\n    }\n}\n```\n\n## 滑动窗口\n\n### 无重复字符的最长子串\n\n给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度。\n\n \n\n**示例 1:**\n\n```\n输入: s = \"abcabcbb\"\n输出: 3 \n解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。注意 \"bca\" 和 \"cab\" 也是正确答案。\n```\n\n**示例 2:**\n\n```\n输入: s = \"bbbbb\"\n输出: 1\n解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。\n```\n\n**示例 3:**\n\n```\n输入: s = \"pwwkew\"\n输出: 3\n解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。\n     请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。\n```\n\n \n\n**提示：**\n\n- `0 <= s.length <= 5 * 104`\n- `s` 由英文字母、数字、符号和空格组成\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        // 哈希集合，记录每个字符是否出现过\n        Set<Character> occ = new HashSet<Character>();\n        int n = s.length();\n        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动\n        int rk = -1, ans = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i != 0) {\n                // 左指针向右移动一格，移除一个字符\n                occ.remove(s.charAt(i - 1));\n            }\n            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {\n                // 不断地移动右指针\n                occ.add(s.charAt(rk + 1));\n                ++rk;\n            }\n            // 第 i 到 rk 个字符是一个极长的无重复字符子串\n            ans = Math.max(ans, rk - i + 1);\n        }\n        return ans;\n    }\n}\n\n```\n\n### 找到字符串中所有字母异位词\n\n给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n \n\n**示例 1:**\n\n```\n输入: s = \"cbaebabacd\", p = \"abc\"\n输出: [0,6]\n解释:\n起始索引等于 0 的子串是 \"cba\", 它是 \"abc\" 的异位词。\n起始索引等于 6 的子串是 \"bac\", 它是 \"abc\" 的异位词。\n```\n\n **示例 2:**\n\n```\n输入: s = \"abab\", p = \"ab\"\n输出: [0,1,2]\n解释:\n起始索引等于 0 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n起始索引等于 1 的子串是 \"ba\", 它是 \"ab\" 的异位词。\n起始索引等于 2 的子串是 \"ab\", 它是 \"ab\" 的异位词。\n```\n\n \n\n**提示:**\n\n- `1 <= s.length, p.length <= 3 * 104`\n- `s` 和 `p` 仅包含小写字母\n\n```java\nclass Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        int sLen = s.length(), pLen = p.length();\n\n        if (sLen < pLen) {\n            return new ArrayList<Integer>();\n        }\n\n        List<Integer> ans = new ArrayList<Integer>();\n        int[] sCount = new int[26];\n        int[] pCount = new int[26];\n        for (int i = 0; i < pLen; ++i) {\n            ++sCount[s.charAt(i) - 'a'];\n            ++pCount[p.charAt(i) - 'a'];\n        }\n\n        if (Arrays.equals(sCount, pCount)) {\n            ans.add(0);\n        }\n\n        for (int i = 0; i < sLen - pLen; ++i) {\n            --sCount[s.charAt(i) - 'a'];\n            ++sCount[s.charAt(i + pLen) - 'a'];\n\n            if (Arrays.equals(sCount, pCount)) {\n                ans.add(i + 1);\n            }\n        }\n\n        return ans;\n    }\n}\n\n```\n\n也可使用hash来判断。\n\n## 字串\n\n### 和为K的子数组\n\n给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。\n\n子数组是数组中元素的连续非空序列。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,1,1], k = 2\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3], k = 3\n输出：2\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 2 * 104`\n- `-1000 <= nums[i] <= 1000`\n- `-107 <= k <= 107`\n\n前缀和 + 哈希表优化\n思路和算法\n\n我们可以利用数据结构进行优化，我们知道对每个 i，我们需要枚举所有的 j 来判断是否符合条件，这一步是否可以优化呢？答案是可以的。\n\n我们定义 pre[i] 为 [0..i] 里所有数的和，则 pre[i] 可以由 pre[i−1] 递推而来，即：\n\npre[i]=pre[i−1]+nums[i]\n那么「[j..i] 这个子数组和为 k 」这个条件我们可以转化为\n\npre[i]−pre[j−1]==k\n简单移项可得符合条件的下标 j 需要满足\n\npre[j−1]==pre[i]−k\n所以我们考虑以 i 结尾的和为 k 的连续子数组个数时只要统计有多少个前缀和为 pre[i]−k 的 pre[j] 即可。我们建立哈希表 mp，以和为键，出现次数为对应的值，记录 pre[i] 出现的次数，从左往右边更新 mp 边计算答案，那么以 i 结尾的答案 mp[pre[i]−k] 即可在 O(1) 时间内得到。最后的答案即为所有下标结尾的和为 k 的子数组个数之和。\n\n需要注意的是，从左往右边更新边计算的时候已经保证了mp[pre[i]−k] 里记录的 pre[j] 的下标范围是 0≤j≤i 。同时，由于pre[i] 的计算只与前一项的答案有关，因此我们可以不用建立 pre 数组，直接用 pre 变量来记录 pre[i−1] 的答案即可。\n\n```java\npublic class Solution {\n    public int subarraySum(int[] nums, int k) {\n        int count = 0, pre = 0;\n        HashMap < Integer, Integer > mp = new HashMap<>();\n        mp.put(0, 1);\n        for (int i = 0; i < nums.length; i++) {\n            pre += nums[i];\n            if (mp.containsKey(pre - k)) {\n                count += mp.get(pre - k);\n            }\n            mp.put(pre, mp.getOrDefault(pre, 0) + 1);\n        }\n        return count;\n    }\n}\n```\n\n### 滑动窗口最大值\n\n给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。\n\n返回 *滑动窗口中的最大值* 。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,3,-1,-3,5,3,6,7], k = 3\n输出：[3,3,5,5,6,7]\n解释：\n滑动窗口的位置                最大值\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\n```\n\n**示例 2：**\n\n```\n输入：nums = [1], k = 1\n输出：[1]\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 105`\n- `-104 <= nums[i] <= 104`\n- `1 <= k <= nums.length`\n\n\n\n单调队列：\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        Deque<Integer> deque = new LinkedList<Integer>();\n        for (int i = 0; i < k; ++i) {\n            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n        }\n\n        int[] ans = new int[n - k + 1];\n        ans[0] = nums[deque.peekFirst()];\n        for (int i = k; i < n; ++i) {\n            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            deque.offerLast(i);\n            while (deque.peekFirst() <= i - k) {\n                deque.pollFirst();\n            }\n            ans[i - k + 1] = nums[deque.peekFirst()];\n        }\n        return ans;\n    }\n}\n\n```\n\n**双端队列的作用**：队列中存储的是**数组索引**，且对应的值**从队头到队尾单调递减**。这样队头永远是当前窗口的最大值索引。\n\n**维护队列的两个关键操作**：\n\n- **入队前清理**：新元素入队时，移除队列尾部所有比它小的元素（因为这些元素不可能成为后续窗口的最大值），保证队列单调递减。\n- **出队清理**：移除队列头部超出当前窗口范围的索引（窗口滑动后，旧的最大值不在窗口内了）。\n\n**窗口滑动**：每滑动一次，就将当前队头对应的数值加入结果数组。\n\n\n\n除了基于「随着窗口的移动实时维护最大值」的方法一以及方法二之外，我们还可以考虑其他有趣的做法。\n\n分块+预处理：\n\n```java\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] prefixMax = new int[n];\n        int[] suffixMax = new int[n];\n        for (int i = 0; i < n; ++i) {\n            if (i % k == 0) {\n                prefixMax[i] = nums[i];\n            }\n            else {\n                prefixMax[i] = Math.max(prefixMax[i - 1], nums[i]);\n            }\n        }\n        for (int i = n - 1; i >= 0; --i) {\n            if (i == n - 1 || (i + 1) % k == 0) {\n                suffixMax[i] = nums[i];\n            } else {\n                suffixMax[i] = Math.max(suffixMax[i + 1], nums[i]);\n            }\n        }\n\n        int[] ans = new int[n - k + 1];\n        for (int i = 0; i <= n - k; ++i) {\n            ans[i] = Math.max(suffixMax[i], prefixMax[i + k - 1]);\n        }\n        return ans;\n    }\n}\n```\n\n### 最小覆盖子串\n\n给定两个字符串 `s` 和 `t`，长度分别是 `m` 和 `n`，返回 s 中的 **最短窗口 子串**，使得该子串包含 `t` 中的每一个字符（**包括重复字符**）。如果没有这样的子串，返回空字符串 `\"\"`。\n\n测试用例保证答案唯一。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"\n输出：\"BANC\"\n解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n```\n\n**示例 2：**\n\n```\n输入：s = \"a\", t = \"a\"\n输出：\"a\"\n解释：整个字符串 s 是最小覆盖子串。\n```\n\n**示例 3:**\n\n```\n输入: s = \"a\", t = \"aa\"\n输出: \"\"\n解释: t 中两个字符 'a' 均应包含在 s 的子串中，\n因此没有符合条件的子字符串，返回空字符串。\n```\n\n \n\n**提示：**\n\n- `m == s.length`\n- `n == t.length`\n- `1 <= m, n <= 105`\n- `s` 和 `t` 由英文字母组成\n\n```java\nclass Solution {\n    public String minWindow(String s, String t) {\n        int lens=s.length();\n        int lent=t.length();\n        String res=\"\";\n        int cnt=0;\n        int[] result=new int[200];//窗口字符串\n        int[] countt=new int[200];//目标字符串\n        for(int i=0;i<lent;i++){\n            char c=t.charAt(i);\n            countt[c]++;\n        }\n\n        int minlen=Integer.MAX_VALUE;\n        int start=0;\n\n        for(int i=0,j=0;i<lens;i++){\n            char c=s.charAt(i);\n            result[c]++;\n            \n            //如果窗口中某个字符数量比目标字符串中的字符小，则说明找到需要的字符了\n            if(result[c]<=countt[c]) cnt++;\n\n            //去除左边不需要的\n            while(j<=i&&result[s.charAt(j)]>countt[s.charAt(j)]){\n                result[s.charAt(j)]--;\n                j++;\n            }\n\n\n            if(cnt==lent&&(i-j+1<minlen)){\n                minlen=i-j+1;\n                start=j;\n                res=s.substring(start, start + minlen);\n            }\n            \n        }\n\n    return res;\n\n\n    }\n}\n```\n\n## 普通数组\n\n### 最大子数组和\n\n给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n**子数组**是数组中的一个连续部分。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [-2,1,-3,4,-1,2,1,-5,4]\n输出：6\n解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1]\n输出：1\n```\n\n**示例 3：**\n\n```\n输入：nums = [5,4,-1,7,8]\n输出：23\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 105`\n- `-104 <= nums[i] <= 104`\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        // 获取数组长度\n        int len = nums.length;\n        // 处理边界情况：如果数组为空，直接返回0\n        if (len == 0) return 0;\n        \n        // dp数组定义：dp[i]表示以第i个元素结尾的最大子数组和\n        // 之所以这样定义，是因为最大子数组和必然以某个元素结尾\n        int[] dp = new int[len];\n        \n        // 初始化：第一个元素结尾的最大子数组和就是它本身\n        dp[0] = nums[0];\n        \n        // 全局最大子数组和，初始化为第一个元素的值\n        int maxAns = dp[0];\n        \n        // 从第二个元素开始遍历数组\n        for (int i = 1; i < len; i++) {\n            // 状态转移方程：对于以第i个元素结尾的子数组\n            // 有两种选择：要么自成一个新的子数组（nums[i]）\n            // 要么加入前面以i-1结尾的子数组（dp[i-1] + nums[i]）\n            // 取两者中的较大值\n            dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);\n            \n            // 更新全局最大子数组和\n            maxAns = Math.max(maxAns, dp[i]);\n        }\n        \n        // 返回全局最大子数组和\n        return maxAns;\n    }\n}\n```\n\n### 合并区间\n\n以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。\n\n \n\n**示例 1：**\n\n```\n输入：intervals = [[1,3],[2,6],[8,10],[15,18]]\n输出：[[1,6],[8,10],[15,18]]\n解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].\n```\n\n**示例 2：**\n\n```\n输入：intervals = [[1,4],[4,5]]\n输出：[[1,5]]\n解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。\n```\n\n**示例 3：**\n\n```\n输入：intervals = [[4,7],[1,4]]\n输出：[[1,7]]\n解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。\n```\n\n \n\n**提示：**\n\n- `1 <= intervals.length <= 104`\n- `intervals[i].length == 2`\n- `0 <= starti <= endi <= 104`\n\n```java\nclass Solution {\n    // 定义一个方法，输入是二维数组intervals（每个元素是一个区间[起始, 结束]），输出是合并后的区间数组\n    public int[][] merge(int[][] intervals) {\n        // 1. 处理边界情况：如果输入的区间数组为空，直接返回空的二维数组\n        if (intervals.length == 0) {\n            return new int[0][2];\n        }\n        \n        // 2. 对区间数组进行排序：按照每个区间的起始值（interval[0]）升序排列\n        // 排序是合并区间的前提，确保我们可以按顺序处理重叠区间\n        Arrays.sort(intervals, new Comparator<int[]>() {\n            // 自定义比较器：比较两个区间的起始值\n            public int compare(int[] interval1, int[] interval2) {\n                // 返回值>0则interval1排在后面，<0则排在前面，=0则顺序不变\n                return interval1[0] - interval2[0];\n            }\n        });\n        \n        // 3. 创建一个动态列表merged，用于存储合并后的区间（数组长度固定，列表更灵活）\n        List<int[]> merged = new ArrayList<int[]>();\n        \n        // 4. 遍历所有待合并的区间\n        for (int i = 0; i < intervals.length; ++i) {\n            // 提取当前遍历到的区间的起始值L和结束值R\n            int L = intervals[i][0], R = intervals[i][1];\n            \n            // 5. 判断是否需要合并：\n            //    - 如果merged列表为空（还没有合并过任何区间），直接添加当前区间\n            //    - 如果merged最后一个区间的结束值 < 当前区间的起始值（无重叠），也直接添加\n            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < L) {\n                merged.add(new int[]{L, R});\n            } else {\n                // 6. 有重叠，需要合并：更新merged最后一个区间的结束值为两者的最大值\n                //    比如merged最后一个区间是[1,3]，当前区间是[2,6]，合并后变为[1,6]\n                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);\n            }\n        }\n        \n        // 7. 将动态列表转换为二维数组返回：\n        //    new int[merged.size()][] 是指定返回数组的行数为merged的大小，列数自动适配\n        return merged.toArray(new int[merged.size()][]);\n    }\n}\n```\n\n### 轮转数组\n\n给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右轮转 1 步: [7,1,2,3,4,5,6]\n向右轮转 2 步: [6,7,1,2,3,4,5]\n向右轮转 3 步: [5,6,7,1,2,3,4]\n```\n\n**示例 2:**\n\n```\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右轮转 1 步: [99,-1,-100,3]\n向右轮转 2 步: [3,99,-1,-100]\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 105`\n- `-231 <= nums[i] <= 231 - 1`\n- `0 <= k <= 105`\n\n```java\nclass Solution {\n    // 核心方法：将数组 nums 向右旋转 k 个位置\n    public void rotate(int[] nums, int k) {\n        // 1. 获取数组长度 n\n        int n = nums.length;\n        // 2. 处理 k 大于数组长度的情况（旋转 n 次等于没旋转）\n        // 例如数组长度 5，k=7，等价于旋转 2 次（7%5=2）\n        k = k % n;\n        // 3. 计算 k 和 n 的最大公约数（gcd），确定需要处理的环的数量\n        // 环的数量 = gcd(k, n)，每个环内的元素会互相替换\n        int count = gcd(k, n);\n        // 4. 遍历每个环的起始位置，逐个处理每个环\n        for (int start = 0; start < count; ++start) {\n            // 5. current：当前要处理的元素下标，初始为环的起始位置\n            int current = start;\n            // 6. prev：保存当前位置的元素值，作为下一个位置的替换值\n            int prev = nums[start];\n            // 7. do-while 循环处理当前环的所有元素（至少执行一次）\n            do {\n                // 8. 计算当前元素旋转后的下一个位置（向右移动 k 位）\n                int next = (current + k) % n;\n                // 9. 保存下一个位置的原始值（避免被覆盖）\n                int temp = nums[next];\n                // 10. 将前一个位置的值放到下一个位置（完成一次替换）\n                nums[next] = prev;\n                // 11. 更新 prev 为下一个位置的原始值，用于下一轮替换\n                prev = temp;\n                // 12. 更新 current 为下一个位置，继续处理\n                current = next;\n            // 13. 当 current 回到环的起始位置时，当前环处理完成\n            } while (start != current);\n        }\n    }\n\n    // 辅助方法：用欧几里得算法计算两个数的最大公约数（gcd）\n    public int gcd(int k, int n) {\n        // 递归终止条件：n=0 时，k 就是最大公约数\n        // 否则递归计算 gcd(n, k%n)，直到 n=0\n        return n > 0 ? gcd(n, k % n) : k;\n    }\n}\n```\n\n### 除自身以外数组的乘积\n\n给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除了 `nums[i]` 之外其余各元素的乘积 。\n\n题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。\n\n请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [1,2,3,4]\n输出: [24,12,8,6]\n```\n\n**示例 2:**\n\n```\n输入: nums = [-1,1,0,-3,3]\n输出: [0,0,9,0,0]\n```\n\n \n\n**提示：**\n\n- `2 <= nums.length <= 105`\n- `-30 <= nums[i] <= 30`\n- 输入 **保证** 数组 `answer[i]` 在 **32 位** 整数范围内\n\n```java\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int len=nums.length;\n        //l[0]表示nums[0]左边所有数的乘积\n        int[] l=new int[len];\n        int[] r=new int[len];\n        int[] result=new int[len];\n        l[0]=1;\n        r[len-1]=1;\n        for(int i=1;i<len;i++){\n            l[i]=l[i-1]*nums[i-1];\n        }\n        for(int i=len-2;i>=0;i--){\n            r[i]=r[i+1]*nums[i+1];\n        }\n        for(int i=0;i<len;i++){\n            result[i]=l[i]*r[i];\n        }\n        return result;\n    }\n}\n```\n\n### 缺失的第一个整数\n\n给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。\n\n请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,0]\n输出：3\n解释：范围 [1,2] 中的数字都在数组中。\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,4,-1,1]\n输出：2\n解释：1 在数组中，但 2 没有。\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,8,9,11,12]\n输出：1\n解释：最小的正数 1 没有出现。\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 105`\n- `-231 <= nums[i] <= 231 - 1`\n\n```java\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] <= 0) {\n                nums[i] = n + 1;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            int num = Math.abs(nums[i]);\n            if (num <= n) {\n                nums[num - 1] = -Math.abs(nums[num - 1]);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n        return n + 1;\n    }\n}\n\n```\n\n## 矩阵\n\n### 矩阵置零\n\n给定一个 `*m* x *n*` 的矩阵，如果一个元素为 **0** ，则将其所在行和列的所有元素都设为 **0** 。请使用 **[原地](http://baike.baidu.com/item/原地算法)** 算法**。**\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/08/17/mat1.jpg)\n\n```\n输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]\n输出：[[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2020/08/17/mat2.jpg)\n\n```\n输入：matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\n输出：[[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```\n\n \n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[0].length`\n- `1 <= m, n <= 200`\n- `-231 <= matrix[i][j] <= 231 - 1`\n\n```java\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length, n = matrix[0].length;\n        boolean[] row = new boolean[m];\n        boolean[] col = new boolean[n];\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    row[i] = col[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (row[i] || col[j]) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n    }\n}\n```\n\n### 螺旋矩阵\n\n给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/spiral1.jpg)\n\n```\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[1,2,3,6,9,8,7,4,5]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/13/spiral.jpg)\n\n```\n输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\n输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n \n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= m, n <= 10`\n- `-100 <= matrix[i][j] <= 100`\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> order = new ArrayList<Integer>();\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return order;\n        }\n        int rows = matrix.length, columns = matrix[0].length;\n        boolean[][] visited = new boolean[rows][columns];\n        int total = rows * columns;\n        int row = 0, column = 0;\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int directionIndex = 0;\n        for (int i = 0; i < total; i++) {\n            order.add(matrix[row][column]);\n            visited[row][column] = true;\n            int nextRow = row + directions[directionIndex][0], nextColumn = column + directions[directionIndex][1];\n            if (nextRow < 0 || nextRow >= rows || nextColumn < 0 || nextColumn >= columns || visited[nextRow][nextColumn]) {\n                directionIndex = (directionIndex + 1) % 4;\n            }\n            row += directions[directionIndex][0];\n            column += directions[directionIndex][1];\n        }\n        return order;\n    }\n}\n\n```\n\n### 旋转图像\n\n给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)\n\n```\n输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]\n输出：[[7,4,1],[8,5,2],[9,6,3]]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)\n\n```\n输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\n输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n```\n\n \n\n**提示：**\n\n- `n == matrix.length == matrix[i].length`\n- `1 <= n <= 20`\n- `-1000 <= matrix[i][j] <= 1000`\n\n```java\nclass Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int i = 0; i < n / 2; ++i) {\n            for (int j = 0; j < (n + 1) / 2; ++j) {\n                int temp = matrix[i][j];\n                matrix[i][j] = matrix[n - j - 1][i];\n                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];\n                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];\n                matrix[j][n - i - 1] = temp;\n            }\n        }\n    }\n}\n\n```\n\n对于矩阵中第 *i* 行的第 *j* 个元素，在旋转后，它出现在倒数第 *i* 列的第 *j* 个位置。\n\n### 搜索二维矩阵II\n\n编写一个高效的算法来搜索 `*m* x *n*` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：\n\n- 每行的元素从左到右升序排列。\n- 每列的元素从上到下升序排列。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)\n\n```\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5\n输出：true\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)\n\n```\n输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20\n输出：false\n```\n\n \n\n**提示：**\n\n- `m == matrix.length`\n- `n == matrix[i].length`\n- `1 <= n, m <= 300`\n- `-109 <= matrix[i][j] <= 109`\n- 每行的所有元素从左到右升序排列\n- 每列的所有元素从上到下升序排列\n- `-109 <= target <= 109`\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int m = matrix.length, n = matrix[0].length;\n        int x = 0, y = n - 1;\n        while (x < m && y >= 0) {\n            if (matrix[x][y] == target) {\n                return true;\n            }\n            if (matrix[x][y] > target) {\n                --y;\n            } else {\n                ++x;\n            }\n        }\n        return false;\n    }\n}\n\n```\n\n## 链表\n\n### 相交链表\n\n给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null` 。\n\n图示两个链表在节点 `c1` 开始相交**：**\n\n[![img](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)\n\n题目数据 **保证** 整个链式结构中不存在环。\n\n**注意**，函数返回结果后，链表必须 **保持其原始结构** 。\n\n**自定义评测：**\n\n**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：\n\n- `intersectVal` - 相交的起始节点的值。如果不存在相交节点，这一值为 `0`\n- `listA` - 第一个链表\n- `listB` - 第二个链表\n- `skipA` - 在 `listA` 中（从头节点开始）跳到交叉节点的节点数\n- `skipB` - 在 `listB` 中（从头节点开始）跳到交叉节点的节点数\n\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 `headA` 和 `headB` 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。\n\n \n\n**示例 1：**\n\n[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_1.png)\n\n```\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\n输出：Intersected at '8'\n解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n```\n\n \n\n**示例 2：**\n\n[![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_2.png)\n\n```\n输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\n输出：Intersected at '2'\n解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n```\n\n**示例 3：**\n\n[![img](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)](https://assets.leetcode.com/uploads/2018/12/13/160_example_3.png)\n\n```\n输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\n输出：No intersection\n解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n```\n\n \n\n**提示：**\n\n- `listA` 中节点数目为 `m`\n- `listB` 中节点数目为 `n`\n- `1 <= m, n <= 3 * 104`\n- `1 <= Node.val <= 105`\n- `0 <= skipA <= m`\n- `0 <= skipB <= n`\n- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`\n- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA] == listB[skipB]`\n\n```java\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n        ListNode pA = headA, pB = headB;\n        while (pA != pB) {\n            pA = pA == null ? headB : pA.next;\n            pB = pB == null ? headA : pB.next;\n        }\n        return pA;\n    }\n}\n\n```\n\n情况一：两个链表相交\n\n链表 headA 和 headB 的长度分别是 m 和 n。假设链表 headA 的不相交部分有 a 个节点，链表 headB 的不相交部分有 b 个节点，两个链表相交的部分有 c 个节点，则有 a+c=m，b+c=n。\n\n如果 a=b，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；\n\n如果 a\\\\=b，则指针 pA 会遍历完链表 headA，指针 pB 会遍历完链表 headB，两个指针不会同时到达链表的尾节点，然后指针 pA 移到链表 headB 的头节点，指针 pB 移到链表 headA 的头节点，然后两个指针继续移动，在指针 pA 移动了 a+c+b 次、指针 pB 移动了 b+c+a 次之后，两个指针会同时到达两个链表相交的节点，该节点也是两个指针第一次同时指向的节点，此时返回相交的节点。\n\n情况二：两个链表不相交\n\n链表 headA 和 headB 的长度分别是 m 和 n。考虑当 m=n 和 m\\\\=n 时，两个指针分别会如何移动：\n\n如果 m=n，则两个指针会同时到达两个链表的尾节点，然后同时变成空值 null，此时返回 null；\n\n如果 m\\\\=n，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针 pA 移动了 m+n 次、指针 pB 移动了 n+m 次之后，两个指针会同时变成空值 null，此时返回 null。\n\n### 反转链表\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n```\n输入：head = [1,2]\n输出：[2,1]\n```\n\n**示例 3：**\n\n```\n输入：head = []\n输出：[]\n```\n\n \n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 5000]`\n- `-5000 <= Node.val <= 5000`\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre=null;\n        while(head!=null){\n            ListNode next=head.next;\n            head.next=pre;\n            pre=head;\n            head=next;\n        }\n        return pre;\n    }\n}\n```\n\n### 回文链表\n\n给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/03/pal1linked-list.jpg)\n\n```\n输入：head = [1,2,2,1]\n输出：true\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/03/pal2linked-list.jpg)\n\n```\n输入：head = [1,2]\n输出：false\n```\n\n \n\n**提示：**\n\n- 链表中节点数目在范围`[1, 105]` 内\n- `0 <= Node.val <= 9`\n\n快慢指针：\n\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        //找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = findFirstHalfEnd(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        ListNode p1=head;\n        ListNode p2=secondHalfStart;\n        while(p1!=null&&p2!=null){\n            if(p1.val!=p2.val){\n                return false;\n            }\n            p1=p1.next;\n            p2=p2.next;\n        }\n        return true;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode pre=null;\n        while(head!=null){\n            ListNode next=head.next;\n            head.next=pre;\n            pre=head;\n            head=next;\n        }\n        return pre;\n\n    }\n\n    private ListNode findFirstHalfEnd(ListNode head) {\n        ListNode fast=head;\n        ListNode slow=head;\n        while(fast.next!=null&&fast.next.next!=null){\n            fast=fast.next.next;\n            slow=slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n\n\n## 动态规划\n\n### 单词拆分\n\n给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。\n\n**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n \n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n     注意，你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n \n\n**提示：**\n\n- `1 <= s.length <= 300`\n- `1 <= wordDict.length <= 1000`\n- `1 <= wordDict[i].length <= 20`\n- `s` 和 `wordDict[i]` 仅由小写英文字母组成\n- `wordDict` 中的所有字符串 **互不相同**\n\n```java\npublic class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n\n```\n\n外层循环判断到以第i个字母结尾能否成功拼接，内层循环利用哈希contains来遍历判断是否能够拼接并更新dp[i]。\n\n### 最长递增子序列\n\n给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n**示例 1：**\n\n```\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,0,3,2,3]\n输出：4\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 2500`\n- `-104 <= nums[i] <= 104`\n\n\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums.length==0){\n            return 0;\n        }\n        int max=1;\n        int[] dp=new int[nums.length];//dp[i]表示以下标为i为结尾的最长上升序列\n        for(int i=0;i<nums.length;i++){\n            dp[i]=1;\n            for(int j=0;j<i;j++){\n                if(nums[i]>nums[j]){\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                }\n            }\n            max=Math.max(max,dp[i]);\n\n        }\n        return max;\n    \n    }\n\n}\n```\n\n两层循环，外层记录以dp[i]为结尾的最长上升序列，内层循环遍历前面的dp数组动态改变dp[i]。\n\n\n\n### 乘积最大子数组\n\n给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n测试用例的答案是一个 **32-位** 整数。\n\n**请注意**，一个只包含一个元素的数组的乘积是这个元素的值。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n\n**示例 2:**\n\n```\n输入: nums = [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n \n\n**提示:**\n\n- `1 <= nums.length <= 2 * 104`\n- `-10 <= nums[i] <= 10`\n- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int length = nums.length;\n        long[] maxF = new long[length];\n        long[] minF = new long[length];\n        for (int i = 0; i < length; i++) {\n            maxF[i] = nums[i];\n            minF[i] = nums[i];\n        }\n        for (int i = 1; i < length; ++i) {\n            maxF[i] = Math.max(maxF[i - 1] * nums[i], Math.max(nums[i], minF[i - 1] * nums[i]));\n            minF[i] = Math.min(minF[i - 1] * nums[i], Math.min(nums[i], maxF[i - 1] * nums[i]));\n            if (minF[i] < (-1 << 31)) {\n                minF[i] = nums[i];\n            }\n        }\n        int ans = (int) maxF[0];\n        for (int i = 1; i < length; ++i) {\n            ans = Math.max(ans, (int) maxF[i]);\n        }\n        return ans;\n    }\n}\n\n```\n\n1. **为什么需要同时维护 maxF 和 minF？**\n\n   数组中可能包含负数，当遇到负数时，之前的最小乘积（可能是负数）乘以当前负数，结果会变成正数，反而可能成为新的最大乘积。例如：数组 `[2, -3, -4]`，当遍历到 `-4` 时，`minF[1] = -6`（2*-3），`-6 * -4 = 24` 就是当前的最大乘积。\n\n   \n\n2. **为什么用 long 类型？**\n\n   int 类型的取值范围是 `-2^31` 到 `2^31-1`，多个大数相乘时容易溢出，使用 long 可以临时存储更大的数值，最后再转换回 int，避免计算过程中丢失精度。\n\n   \n\n3. **溢出处理的作用？**\n\n   `(-1 << 31)` 等价于 `Integer.MIN_VALUE`（即 - 2147483648），当 minF [i] 的计算结果小于这个值时，说明已经溢出 int 的最小值范围，此时重置为当前数，避免后续计算出错。\n\n\n### 分割等和子集\n\n给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 200`\n- `1 <= nums[i] <= 100`\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (int num : nums) {\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        boolean[][] dp = new boolean[n][target + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        dp[0][nums[0]] = true;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            for (int j = 1; j <= target; j++) {\n                if (j >= num) {\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n - 1][target];\n    }\n}\n\n```\n\n创建二维数组 dp，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。\n\n在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。\n\n如果不选取任何正整数，则被选取的正整数之和等于 0。因此对于所有 0≤i<n，都有 dp[i][0]=true。\n\n当 i==0 时，只有一个正整数 nums[0] 可以被选取，因此 dp[0][nums[0]]=true。\n\n对于 i>0 且 j>0 的情况，如何确定 dp[i][j] 的值？需要分别考虑以下两种情况。\n\n如果 j≥nums[i]，则对于当前的数字 nums[i]，可以选取也可以不选取，两种情况只要有一个为 true，就有 dp[i][j]=true。\n\n如果不选取 nums[i]，则 dp[i][j]=dp[i−1][j]；\n如果选取 nums[i]，则 dp[i][j]=dp[i−1][j−nums[i]]。\n如果 j<nums[i]，则在选取的数字的和等于 j 的情况下无法选取当前的数字 nums[i]，因此有 dp[i][j]=dp[i−1][j]。\n\n状态转移方程如下：\n\ndp[i][j]={ \ndp[i−1][j] ∣ dp[i−1][j−nums[i]],  j≥nums[i]\ndp[i−1][j],  j<nums[i]\n\n最终得到 dp[n−1][target] 即为答案。\n\n### 最长有效括号\n\n给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。\n\n左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 `\"(()())\"`。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n**示例 2：**\n\n```\n输入：s = \")()())\"\n输出：4\n解释：最长有效括号子串是 \"()()\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"\"\n输出：0\n```\n\n \n\n**提示：**\n\n- `0 <= s.length <= 3 * 104`\n- `s[i]` 为 `'('` 或 `')'`\n\n```java\nclass Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxans = Math.max(maxans, i - stack.peek());\n                }\n            }\n            \n        }\n        \n        return maxans;\n    }\n}\n\n```\n\n**遇到左括号 `(`**：直接将当前索引 `i` 压入栈。\n\n目的：记录左括号的位置，等待后续右括号来匹配。\n\n**遇到右括号 `)`**：\n\n① 先执行 `stack.pop()`：\n\n- 如果栈顶是左括号的索引（比如 `(` 在 0 位），弹出后栈顶会回到基准位置（-1），此时可以计算有效长度。\n\n- 如果栈顶是基准位置（比如连续 \n\n  ```\n  ))\n  ```\n\n  ），弹出后栈为空，需要把当前索引压入作为新基准。\n\n  \n\n  ② 栈空判断：\n\n- 栈空 → 说明当前右括号无法匹配，把当前索引 `i` 压入栈，作为新的「无效基准」。\n\n- 栈非空 → 用当前索引 `i` 减去栈顶值，得到**以当前右括号结尾的有效括号长度**，并更新最大值 `maxans`。\n\n## 多维动态规划\n\n### 最小路径和\n\n给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)\n\n```\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n**示例 2：**\n\n```\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n```\n\n \n\n**提示：**\n\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 200`\n- `0 <= grid[i][j] <= 200`\n\n```java\n\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        int x=grid.length;\n        int y=grid[0].length;\n        int[][] dp=new int[x][y];\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<x;i++){\n            dp[i][0]=dp[i-1][0]+grid[i][0];\n        }\n        for(int j=1;j<y;j++){\n            dp[0][j]=dp[0][j-1]+grid[0][j];\n        }\n        for(int i=1;i<x;i++){\n            for(int j=1;j<y;j++){\n                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[x-1][y-1];\n\n    }\n}\n```\n\n先初始化dp数组的第一行第一列，后续当前块最小值都是取min（当前块上边，当前块左边）+当前块。\n\n### 不同路径\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n \n\n**示例 1：**\n\n![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)\n\n```\n输入：m = 3, n = 7\n输出：28\n```\n\n**示例 2：**\n\n```\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n```\n\n**示例 3：**\n\n```\n输入：m = 7, n = 3\n输出：28\n```\n\n**示例 4：**\n\n```\n输入：m = 3, n = 3\n输出：6\n```\n\n \n\n**提示：**\n\n- `1 <= m, n <= 100`\n- 题目数据保证答案小于等于 `2 * 109`\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            dp[i][0]=1;\n        }\n        for(int j=0;j<n;j++){\n            dp[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n\n    }\n}\n```\n\n与最小路径和类似，不做过多解释。\n\n### 最长回文子串\n\n给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n \n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s` 仅由数字和英文字母组成\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() < 2) {\n            return s;\n        }\n        int maxLen = 1;\n        int start = 0;\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n\n        // 单个字符都是回文\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n\n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                maxLen = 2;\n                start = i;\n            }\n        }\n\n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {  // len是子串长度\n            for (int i = 0; i <= n - len; i++) {  // i是起始索引\n                int j = i + len - 1;  // j是结束索引\n\n                // 如果首尾字符相等且中间子串是回文，则当前子串是回文\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n\n                    // 更新最长回文串信息\n                    if (len > maxLen) {\n                        maxLen = len;\n                        start = i;\n                    }\n                }\n            }\n        }\n\n        return s.substring(start, start + maxLen);\n    }\n}\n```\n\n判断一个字符串是否为回文字符串，需要根据首尾相同+中间部分是回文串就行了。\n\n### 最长公共子序列\n\n给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n\n一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n- 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n\n两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n**示例 1：**\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n**示例 2：**\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n**示例 3：**\n\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n \n\n**提示：**\n\n- `1 <= text1.length, text2.length <= 1000`\n- `text1` 和 `text2` 仅由小写英文字符组成。\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.charAt(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.charAt(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n\n```\n\n核心在于：dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n\n如果字符不相等，取「不考虑text1当前字符」或「不考虑text2当前字符」的最大值。\n\n### 编辑距离\n\n给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n \n\n**示例 1：**\n\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n \n\n**提示：**\n\n- `0 <= word1.length, word2.length <= 500`\n- `word1` 和 `word2` 由小写英文字母组成\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int n = word1.length();\n        int m = word2.length();\n\n        // 有一个字符串为空串\n        if (n * m == 0) {\n            return n + m;\n        }\n\n        // DP 数组\n        int[][] D = new int[n + 1][m + 1];\n\n        // 边界状态初始化\n        for (int i = 0; i < n + 1; i++) {\n            D[i][0] = i;\n        }\n        for (int j = 0; j < m + 1; j++) {\n            D[0][j] = j;\n        }\n\n        // 计算所有 DP 值\n        for (int i = 1; i < n + 1; i++) {\n            for (int j = 1; j < m + 1; j++) {\n                int left = D[i - 1][j] + 1;\n                int down = D[i][j - 1] + 1;\n                int left_down = D[i - 1][j - 1];\n                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {\n                    left_down += 1;\n                }\n                D[i][j] = Math.min(left, Math.min(down, left_down));\n            }\n        }\n        return D[n][m];\n    }\n}\n\n```\n\n状态转移的三种核心操作：\n\n1. **删除**：`left = D[i-1][j] + 1` → 删除 `word1` 的第 `i` 个字符，等价于先把 `word1` 前 `i-1` 个字符转成 `word2` 前 `j` 个字符，再删 1 次。\n2. **插入**：`down = D[i][j-1] + 1` → 向 `word1` 插入 `word2` 的第 `j` 个字符，等价于先把 `word1` 前 `i` 个字符转成 `word2` 前 `j-1` 个字符，再插 1 次。\n3. **替换 / 匹配**：`left_down` → 若 `word1[i-1] == word2[j-1]`，无需操作；若不等，替换 `word1[i-1]` 为 `word2[j-1]`，加 1 次操作。\n\n状态转移：每一步从**删除、插入、替换**三种操作中选代价最小的，字符相等时替换操作无需额外代价。\n\n## 技巧\n\n### 只出现一次的数字\n\n给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n \n\n**示例 1 ：**\n\n**输入：**nums = [2,2,1]\n\n**输出：**1\n\n**示例 2 ：**\n\n**输入：**nums = [4,1,2,1,2]\n\n**输出：**4\n\n**示例 3 ：**\n\n**输入：**nums = [1]\n\n**输出：**1\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 3 * 104`\n- `-3 * 104 <= nums[i] <= 3 * 104`\n- 除了某个元素只出现一次以外，其余每个元素均出现两次。\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int sum=0;\n        for(int i=0;i<nums.length;i++){\n            sum^=nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n采用异或方式，相同数异或为0，0与a异或结尾2为a。且满足交换律\n\n### 多数元素\n\n给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,2,3]\n输出：3\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,1,1,1,2,2]\n输出：2\n```\n\n \n\n**提示：**\n\n- `n == nums.length`\n- `1 <= n <= 5 * 104`\n- `-109 <= nums[i] <= 109`\n- 输入保证数组中一定有一个多数元素。\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length / 2];\n    }\n}\n\n```\n\n### 颜色分类\n\n给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。\n\n必须在不使用库内置的 sort 函数的情况下解决这个问题。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,0,2,1,1,0]\n输出：[0,0,1,1,2,2]\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,0,1]\n输出：[0,1,2]\n```\n\n \n\n**提示：**\n\n- `n == nums.length`\n- `1 <= n <= 300`\n- `nums[i]` 为 `0`、`1` 或 `2`\n\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int n = nums.length;\n        int p0 = 0, p2 = n - 1;\n        for (int i = 0; i <= p2; ++i) {\n            while (i <= p2 && nums[i] == 2) {\n                int temp = nums[i];\n                nums[i] = nums[p2];\n                nums[p2] = temp;\n                --p2;\n            }\n            if (nums[i] == 0) {\n                int temp = nums[i];\n                nums[i] = nums[p0];\n                nums[p0] = temp;\n                ++p0;\n            }\n        }\n    }\n}\n\n```\n\n把2移到最右边，0移到最左边\n\n### 下一个排列\n\n整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[1,3,2]\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,1]\n输出：[1,2,3]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,1,5]\n输出：[1,5,1]\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`\n\n```\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (j >= 0 && nums[i] >= nums[j]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    public void reverse(int[] nums, int start) {\n        int left = start, right = nums.length - 1;\n        while (left < right) {\n            swap(nums, left, right);\n            left++;\n            right--;\n        }\n    }\n}\n\n```\n\n思路及解法\n\n注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：\n\n我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。\n\n同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。\n\n以排列 [4,5,2,6,3,1] 为例：\n\n我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。\n\n当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。\n\n具体地，我们这样描述该算法，对于长度为 n 的排列 a：\n\n首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。\n\n如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。\n\n交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。\n\n### 寻找重复数\n\n给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。\n\n假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。\n\n你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,3,4,2,2]\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,1,3,4,2]\n输出：3\n```\n\n**示例 3 :**\n\n```\n输入：nums = [3,3,3,3,3]\n输出：3\n```\n\n \n\n \n\n**提示：**\n\n- `1 <= n <= 105`\n- `nums.length == n + 1`\n- `1 <= nums[i] <= n`\n- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**\n\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = nums[0];\n        int fast = nums[0];\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        int find = nums[0];\n        while (slow != find) {\n            slow = nums[slow];\n            find = nums[find];\n        }\n        return find;\n    }\n}\n```\n\n这是一个检测链表是否有环的算法，正好符合题意。\n","tags":["leetcode","代码"],"categories":["leetcode"]},{"title":"Hello World","url":"/2013/12/24/hello-world/","content":"\nWelcome to [Hexo](http://zespia.tw/hexo)! This is your very first post. Check [documentation](http://zespia.tw/hexo/docs) to learn how to use.\n"}]