[{"title":"「城⻝记」-基于redis的本地⽣活点评系统","url":"/2025/10/21/chengshiji/","content":"\n# 城食记 (ChengShiJi)：Redis 在高并发场景下的 6 大核心应用实战\n\n> **项目背景**：「城食记」是我在深入学习 Java 高并发编程后，设计并实现的一个本地生活服务平台（类似大众点评 / 美团）。在开发过程中，为了解决高并发下的热点数据查询、库存超卖、用户状态管理等问题，我将 Redis 的应用深度融入到了业务架构中。\n\n------\n\n## 用户登录与状态管理：基于 Token 的分布式 Session\n\n在单体应用中，我们习惯用 `HttpSession` 存储用户状态。但在「城食记」的设计中，为了支持分布式部署和水平扩展，我采用了 **Redis + Token** 的无状态登录方案。\n\n### 核心流程\n\n1. **发送验证码**：用户输入手机号，后端生成验证码存入 Redis（Key: `login:code:{phone}`），设置 5 分钟过期。\n\n2. 登录校验：\n\n   - 校验手机号和 Redis 中的验证码。\n- 若用户不存在则自动注册。\n   - 生成 **UUID** 作为 Token。\n   - 将用户信息（UserDTO）转为 Hash 结构存入 Redis（Key: `login:token:{token}`），设置 30 分钟过期。\n   \n   \n\n3. 状态保持：\n\n   - 前端获取 Token 后存储在 LocalStorage，并在后续请求头（Header）中携带。\n   - 后端通过拦截器（Interceptor）解析 Header 中的 Token，从 Redis 获取用户信息并存入 `ThreadLocal`，供后续业务使用。\n   \n   \n\n### 技术亮点\n\n- **无状态设计**：服务端不保存用户状态，完全依赖 Redis，易于水平扩展。\n- **安全性**：Token 设置过期时间，即使泄露也有有效期限制。\n\n------\n\n## 店铺缓存：解决三大缓存问题\n\n店铺详情页是「城食记」的高频访问场景，直接查询数据库压力巨大。我在项目中实现了多级缓存策略，并针对经典的缓存问题设计了对应的解决方案。\n\n### 缓存穿透 (Cache Penetration)\n\n- **问题**：黑客或恶意用户频繁请求不存在的 ID（如 `-1`），导致请求直接打穿缓存到数据库。\n\n- 我的解决方案：缓存空对象。\n\n  - 当数据库查询为空时，仍将该 Key 存入 Redis，Value 为空字符串 `\"\"`，并设置较短的过期时间（如 1 分钟）。\n  - 后续请求该 ID 会直接命中 Redis 的空值，保护数据库。\n\n  \n\n### 缓存击穿 (Cache Breakdown)\n\n- **问题**：一个热点 Key（如超级大 V 的店铺）突然过期，此时大量并发请求涌入，瞬间压垮数据库。\n\n- 我的解决方案 A：互斥锁 (Mutex Lock)\n\n  - 利用 Redis 的 `SETNX` 实现分布式锁。\n  - 只有获取到锁的线程能去查询数据库并重建缓存，其他线程等待重试。\n\n  \n\n- 我的解决方案 B：逻辑过期 (Logical Expire)\n\n   —— \n\n  项目最终采用方案\n\n  - 缓存数据不过期（TTL = -1），但在 Value 中嵌入一个过期时间字段。\n  - 线程查询时发现逻辑过期，直接返回旧数据，并开启一个独立线程（线程池）去后台重建缓存。\n  - **优点**：无锁，性能极高，不阻塞用户请求。\n\n  \n\n### 缓存雪崩 (Cache Avalanche)\n\n- **问题**：大量 Key 在同一时间过期。\n- **我的解决方案**：给缓存过期时间添加 **随机值**（Random TTL），分散过期时间点。\n\n------\n\n## 分布式锁：基于 Redis 的并发控制\n\n在秒杀、库存扣减等场景中，单机锁（Synchronized/ReentrantLock）失效，必须使用分布式锁。\n\n### 简易版分布式锁\n\n利用 `SETNX` (Set If Not Exists) 命令：\n\n```\nSET lock:key unique_id NX PX 10000\n```\n\n`NX`：不存在才设置。\n\n`PX`：自动过期时间（防止死锁）。\n\n### 完善的分布式锁 (Redisson)\n\n手写 Lua 脚本虽然可行，但维护成本高。在「城食记」中，我引入了 **Redisson** 框架，它提供了更强大的功能：\n\n- **可重入锁**：利用 Hash 记录线程 ID 和重入次数。\n- **锁续期 (WatchDog)**：如果业务执行时间超过锁的过期时间，Redisson 会自动延长锁的有效期，防止锁提前释放。\n- **公平锁**：保证请求的顺序性。\n\n------\n\n## 点赞与排行榜：ZSet 的妙用\n\n点赞功能需要支持：点赞 / 取消、按时间排序显示点赞列表、统计点赞数。\n\n### 数据结构选择\n\n我选择了 **ZSet (Sorted Set)** 来实现这一功能：\n\n- **Key**: `blog:liked:{blogId}`\n- **Value (Member)**: `userId`\n- **Score**: `System.currentTimeMillis()` (时间戳)\n\n### 核心操作\n\n- **点赞**：`ZADD`（添加用户 ID 和当前时间戳）。\n- **取消点赞**：`ZREM`（移除用户 ID）。\n- **判断是否点赞**：`ZSCORE`（返回 null 表示未点赞）。\n- **点赞排行榜**：`ZREVRANGE`（按 Score 倒序排列，即最新点赞在前）。\n- **点赞数**：`ZCARD`（获取集合元素数量）。\n\n------\n\n## 签到功能：Bitmap 位图\n\n用户签到是一个典型的 “存粹记录状态” 的场景，且数据量极大。\n\n### 为什么用 Bitmap？\n\n如果用关系型数据库存，一个用户一年 365 条记录，数据量会非常大。\n\n在「城食记」中，我使用了 **Bitmap**，用一个比特位（bit）表示一天的状态（0 未签，1 已签）。\n\n- 一年 365 天 = 365 bits ≈ **46 Bytes**。\n- 极大节省内存空间。\n\n### 核心实现\n\n- **Key**: `sign:{userId}:{yyyyMM}`\n\n- **Offset**: `dayOfMonth - 1` (当月的第几天，从 0 开始)\n\n- **签到**：`SETBIT key offset 1`\n\n- 统计连续签到天数\n\n  ：\n\n  - 使用 `BITFIELD` 命令读取当月截至今天的所有 bit 位。\n  - 返回一个十进制数字，通过位运算（`& 1` 和 `>> 1`）从后往前遍历，统计末尾连续 1 的个数。\n\n  \n\n------\n\n## 秒杀与异步下单：Stream 消息队列\n\n秒杀业务的核心挑战是高并发读写和超卖问题。\n\n### 核心流程\n\n1. **校验**：用户资格及库存预判断（Redis）。\n\n2. **扣减库存**：利用 Redis 的 `DECR` 原子操作扣减库存。\n\n3. 异步下单\n\n   ：\n\n   - 传统做法是直接操作数据库创建订单，容易造成拥堵。\n   - **优化**：将下单信息（用户 ID、商品 ID）发送到 **Redis Stream** 队列。\n   - 后台开启一个线程（消费者），从 Stream 中拉取消息，异步写入 MySQL 创建订单。\n\n   \n\n### 技术价值\n\n- **削峰填谷**：瞬间的高并发写入变成了队列的平稳消费。\n- **解耦**：秒杀服务只负责资格校验和入队，订单服务负责落库。\n\n## 项目总结\n\n通过「城食记」这个项目，我不仅仅是完成了业务功能的开发，更重要的是将 Redis 的各种数据结构和特性深度结合到了实际场景中：\n\n1. **缓存设计**不仅仅是 `set` 和 `get`，更重要的是解决一致性和异常问题（穿透、击穿、雪崩）。\n2. **数据结构选型**的重要性：String 做缓存，Hash 存对象，ZSet 做排序和计数，Bitmap 做海量状态压缩，Stream 做消息队列。\n3. **分布式思维**：在多机部署环境下，锁、Session、事务都需要特殊的处理机制。","tags":["java","项目","技术"],"categories":["java"]},{"title":"Spintboot介绍","url":"/2025/07/11/springboot/","content":"\n# SpringBoot 全面介绍\n\nSpringBoot 是由 Pivotal 团队（后归属于 VMware）基于 Spring 框架推出的**轻量级、约定优于配置**的开源框架，核心目标是**简化 Spring 应用的开发、配置、部署和运维**，让开发者能够快速搭建生产级别的 Spring 应用。\n\n## 核心定位\n\nSpringBoot 并非替代 Spring，而是对 Spring 框架的**封装和增强**：\n\n- 解决 Spring 原生开发中 “配置繁琐、依赖管理复杂、部署麻烦” 等痛点；\n- 提供 “开箱即用” 的能力，同时保留足够的灵活性（支持自定义配置）；\n- 专注于快速构建独立的、可运行的 Spring 应用（尤其是微服务场景）。\n\n## 核心特性\n\n### 约定优于配置（Convention over Configuration）\n\nSpringBoot 内置了大量默认配置规则，无需手动编写 XML 配置（如 Spring 传统的 `applicationContext.xml`），仅需少量配置（甚至零配置）即可启动应用：\n\n- 默认扫描主程序所在包及其子包的组件；\n- 默认配置数据源、日志、Web 容器（Tomcat）等核心组件；\n- 通过 `application.yml/application.properties` 即可覆盖默认配置。\n\n### 自动配置（AutoConfiguration）\n\n这是 SpringBoot 最核心的特性：\n\n- 基于项目中引入的依赖（如 `spring-boot-starter-web`），自动识别并配置相关组件（如 DispatcherServlet、Tomcat、Jackson 等）；\n- 底层通过 `@EnableAutoConfiguration` 注解结合 SPI（服务提供者接口）机制实现，开发者可通过 `@Conditional` 系列注解自定义自动配置规则；\n- 支持通过 `spring-boot-starter` 依赖 Starter 套件，一键引入场景化依赖（如 Web、数据库、缓存、消息队列等）。\n\n### 起步依赖（Starter Dependencies）\n\n将常用场景的依赖打包成统一的 Starter，避免手动管理依赖版本和依赖冲突：\n\n| 常用 Starter                   | 用途                            |\n| ------------------------------ | ------------------------------- |\n| `spring-boot-starter-web`      | Web 开发（Spring MVC + Tomcat） |\n| `spring-boot-starter-data-jpa` | 持久层（JPA + Hibernate）       |\n| `spring-boot-starter-mybatis`  | 持久层（MyBatis）               |\n| `spring-boot-starter-redis`    | Redis 缓存操作                  |\n| `spring-boot-starter-test`     | 单元测试（JUnit + Mockito）     |\n\n### 嵌入式容器\n\nSpringBoot 内置了 Tomcat（默认）、Jetty、Undertow 等 Servlet 容器，应用可直接打成 **可执行 JAR 包**，无需手动部署到外部容器：\n\n- 执行 `java -jar xxx.jar` 即可启动应用；\n- 支持通过配置修改容器端口、线程池等参数。\n\n### 监控与运维\n\n- 内置 `spring-boot-starter-actuator`，可暴露应用健康状态、指标、日志、环境变量等监控端点（如 `/actuator/health`、`/actuator/metrics`）；\n- 支持与 Prometheus、Grafana 等监控工具集成，实现可视化监控和告警；\n- 支持热部署（`spring-boot-devtools`），开发阶段无需重启应用即可生效代码修改。\n\n### 简化部署\n\n- 支持打包为可执行 JAR/WAR 包，也支持 Docker 容器化部署；\n- 与 CI/CD 工具（Jenkins、GitLab CI）无缝集成，简化持续交付流程。\n\n### 无代码生成 & 无 XML 配置\n\n完全基于注解驱动开发，无需生成额外代码，也无需编写 XML 配置文件，核心配置通过注解（如 `@SpringBootApplication`、`@RestController`）和配置文件实现。","tags":["SpringBoot"],"categories":["java"]},{"title":"java基础","url":"/2025/07/10/Javabasic/","content":"\n## Day1\n\n随便写一个整数，默认是int类型，如果将一个超过int范围的数赋值给一个long类型的变量\n\n`long l1 = 334254235555`则会报错，因为超出了int范围。正确写法是加数后面加上L或l指定类型。\n\n如果是任意写一个浮点数，则默认是double类型的，若要指定为float则加上f\n\nchar既是字符，又能当作数值运算。\n\n## Day2\n在表达式中，小范围类型的变量，会自动转换成表达式中较大范围的类型，再参与运算。\n\nbyte、short、char —> int —>long —>float —> double\n\n+ 表达式的最终结果类型由表达式中的最高类型决定。\n+ 在表达式中，**byte、short、char是直接转换成int类型参与运算的。**\n\n扩展的赋值运算符(+= -= *= /= %=)隐含了强制类型转换\n\n&&和&区别 判断结果一样,&&短路与会提前中断。\n\n||和|区别，判断结果一样，||短路或会提前中断。\n\n## Day3\nSwitch 表达式类型只能是byte、short、int、char,JDK5开始支持枚举，JDK7开始支持String,不支持double、float、long。case给出的值不能重复，且只能是字面量，不能是变量。不要忘写break。\n\n### 数组\n```java\n//静态初始化数组 定义时已确定数据\n数据类型[] 数据名 = {元素1,元素2,元素3,..。};\nint[] arr = {12,24,36};\n//完整格式\n数据类型[] 数据名 = new 数据类型[]{元素1，元素2，元素3...}\nint[] arr = new int[]{12,24,36};\n//动态初始化数组\n数据类型[] 数据名 = new 数据类型[长度]\nint[] arr = new int[3];\n```\n\n## Day4\n类默认就自带了一个无参构造器(类似C++的构造函数)\n\n为类定义了有参数构造器，那么类默认的无参数构造器就没有了，此时如果还想用无参数构造器，就必须手写一个无参数构造器\n\n类的属性前面加static,意为静态变量，类的静态变量是共用的，在内存中占一处空间，一般是用类名.属性名来使用。\n\n类的方法前面加staic,意为静态方法，静态方法可以用来设计工具类，工具类中的方法都是静态方法，每个类方法用来完成一个功能，提高代码复用性。\n\n**静态方法和实例方法的区别:**静态方法可以直接访问静态成员，但不可以访问实例成员(静态成员存储在方法区，在类加载时初始化，与类本身绑定，静态方法本身没有隐含的`this`引用，)\n\n子类对象包含父类的所有成员，因为子类实例化时回调用父类的构造函数初始化父类的成员。虽然私有变量存在于子类对象中，但是子类无法通过变量名直接操作它们(需要通过父类提供的public/protected方法访问)\n\n### 权限修饰符\nprivate 本类\n\ndefault(缺省) 本类、同一个包中的类\n\nprotected 本类，同一个包的类、子孙类中\n\npublic 任意位置\n\n## Day5\n### 重写\n@Override 重写标识符\n\n子类重写Object类的toString()方法(默认返回对象地址)，以便放回对象的内容。\n\n### this()\n默认情况下，子类全部构造器的第一行代码都是super()，它会调用父类的无参数构造器。\n\n如果父类没有无参数构造器，则我们必须要在子类构造器的第一行手写super(...),去指定调用父类的有参构造器。\n\n**super构造器或this构造器必须写在构造器的第一行 并且不能同时出现**\n\n### 多态\n多态前提:有继承/实现关系;存在父类引用子类对象；存在方法重写\n\n```plain\nPeople p1 = new Student();\np1.run();\n\nPeople p2 = new Teacher();\np2.run();\n```\n\nJava多态表现为对象多态、行为多态(方法重写)\n\n多态是对象、行为的多态， 方法:编译看左，左即左边的类 运行看右 成员变量:编译看左，运行也看左 这里的“左”指的是**引用类型**，也就是声明对象时等号左边的类型。\n\n成员变量和方法不同，它们**不具备多态性**。**无论运行时实际对象是什么类型，访问成员变量时，永远只看引用类型（左边）的成员变量。**\n\n多态下不能调子类独有功能 （编译器为了保证代码的安全性，只允许你调用左边引用类型所拥有的功能。)\n\n多态好处:右边对象解耦合，便于拓展维护。定义方法时，使用父类类型形参可以接收一切子类对象，扩展性强\n\n```plain\n遇到的问题:\n\nQ:Animal a1 = new Tortoise();\n\nTortoise t1 = a1;直接这样写为什么不行 a1难道不算Tortoise的对象吗?前面不是刚new了一遍吗\n\nTortoise t1 = (Tortoise) a1; 为什么必须像这样强制转换了才能用?\n\nA:编译器的保护机制，使得开发者必须强制类型转换告诉编译器知道a1是Tortoise类型。\n\nAnimal a1 = new Tortoise();\n\nParrot p1 = (Parrot) a1 这样写编译时不保存，但是运行时会发现试图将Tortoise类型的对象转换成Parrot,会报错ClassCastException。\n```\n\n**Java建议在强制转换前，应该判断对象的真实类型，再进行强制类型转换。**(用instanceof)\n\n## Day6\n### final关键字\nfinal修饰静态变量，这个变量今后被称为常量，常量名称建议全部大写。\n\n被final修饰的量**不能被继承**\n\n修饰基本类型变量，变量存储的**数据**不能被改变。\n\n修饰引用类型变量(数组)，变量存储的**地址**不能被改变，但地址所指对象的内容可变。\n\n### 设计模式\n单例设计模式\n\n```java\n//单例设计模式\npublic class A{\n    private static A a =new A()；\n    //私有化构造器\n    private A(){\n    \n    }\n    public static A getInstance(){\n        return a;\n    }\n}\n//懒汉式单例类 延迟加载对象\npublic class B{\n    private static B b；\n    //私有化构造器\n    private b(){\n    }\n    public static B getInstance(){\n        if(b == null){\n            b = new B();\n        }\n        return b;\n    }\n}\n```\n\n模板方法设计模式\n\n1、定义一个抽象类。\n\n2、在里面定义2个方法\n\n+ 一个是模板方法：把共同的实现步骤放里面去。\n+ 一个是抽象方法：不确定的实现步骤，交给具体的子类来完成。\n\n### 枚举类\n枚举类是final最终类不可被继承，枚举类继承java.lang.Enum类 枚举类第一行只能罗列一些常量名称，**常量回记住枚举类的一个对象。**构造器为私有，对外不能创建对象。编译器为枚举类新增了几个方法。\n\n```java\npublic enum A{\n    X,Y,Z;\n}\nComplied from \"A.java\"\npublic final class A extends java.lang.Enum<A>{\n    public static fianl A X = new A();\n    public static fianl A Y = new A();\n    public static fianl A Z = new A();\n    \n    public static A[] values();\n    public static A valueOf(java.lang.String);\n\n}\n```\n\n### 抽象类\n用abstract修饰；抽象方法只有方法签名，不能写方法体。\n\n可以不写抽象方法，但有**抽象方法的类必须是抽象类**，类有的成员，抽象类都具备。\n\n**抽象类不能创建对象**，仅作为一种特殊的父类让子类继承并实现。**抽象类的子类必须重写父类的所有抽象方法**，除非子类本身也被声明为 `abstract`\n\n### 接口\n使用interface关键字定义的一种结构，JDK8之前，接口中只能定义成员变量(常量)和成员方法(抽象方法)。\n\n`实现类`实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类。\t\n\n修饰符 class 实现类类名 implements 接口1，接口2，接口3， ...{\n\n}\n\n接口在高版本支持默认方法，私有方法private\n\n**注意事项：**\n\n+ 接口与接口可以多继承：一个接口可以同时继承多个接口[重点]\n+ 一个接口继承多个接口，如果多个接口存在方法签名冲突（方法名和参数列表相同但返回类型不同的方法)则此时不支持多继承，也不支持多实现\n+ _一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的_\n+ 一个类实现了多个接口，如果多个接口中存在同名的方法，可以不冲突，\n\n### 匿名内部类\n书写格式:\n\n```java\nnew 类或接口(参数值...){\n     类体(一般是方法重写);\n}\n\nnew Animal(){\n @Override\n public void cry(){\n }\n};\n```\n\n匿名内部类本质就是一个子类，并会立即创建出一个子类对象。\n\n匿名内部类实际上有名字(在编译后产生类文件)外部类名$编号.class\n\n**匿名类的本质是编译器自动生成一个没有名字的实现类，并直接实例化。**\n\n`public static void start(Swim s)`这里的s可以直接用下面这种方式传参\n\n```java\nstart(new Swim(){\n    @Override\n    pubic void swimming(){\n        System.out.printlin(\"游泳1\");\n    }\n});\n```\n\n使用场景一:为按钮添加事件监听器对象\n\n使用场景二:使用comparator接口的匿名内部类实现对数组排序\n\n### Lambda\nLambda表达式只能简化函数式接口的匿名内部类\n\n```java\n@FunctionalInterface // 声明函数式接口的注解 声明后只能写一个抽象方法\ninterface Swim{\n    void swimming();\n}\n\n/*Swim s1 = new Swim(){\n    @Override\n    public void swimming(){\n        System.out.println(\"学生游泳\");\n    }\n};\n*/\nSwim s1 = () - > {\n    System.out.println(\"学生游泳\");\n};\n\n\n```\n\n\n\n函数式接口:只有一个抽象方法的接口  \n`@FunctionInterface`声明函数式接口的注解\n\n\n\n#### 静态方法引用\n类名::静态方法 使用场景:Lambda表达式只调用**一个**静态方法，并且\"->\"前后参数形式一致，就可以使用静态方法引用。\n\n#### 实例方法引用\n对象名::实例方法 使用场景:如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“->”前后参数的形式一致，就可以使用实例方法引用。\n\n#### 特定方法类型引用\n特性类的名称::方法 使用场景:某个lambda表达式中只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时可以使用特定类型的方法引用。\n\n```java\nArrays.sort(names);\nArrays.sort(names,new Comparator<String>(){\n    @Override\n    public int compare(String o1,String o2){\n        //o1 a1\n        //o2 a2\n        return o1.compareToIgnoreCase(o2);\n    }\n});\nArrays.sort(names,(o1,o2) -> o1.compareToIgnoreCase(o2));\n//特定类型方法引用: 类型名称::方法名\nArrays.sort(names,String::compareToIgnoreCase);\n\nSystem.out.printlin(Arrays.toString(names));\n```\n\n\n\n#### 构造器引用\n类名::new 使用场景:如果某个lambda表达式里只是在创建对象，并且“->”前后参数情况一致，就可以使用构造器引用。\n\n### String\n创建对象封装字符串数据的方式\n\n+ 直接使用双引号“...”(会存储到字符串常量池，并且相同内容的字符串只存储一份)\n+ new String类，调用构造器初始化字符串对象(每new一次都会产生一个新的对象放到堆内存中)\n\n","tags":["java"],"categories":["java"]},{"title":"java介绍","url":"/2025/07/10/java/","content":"\n# Java 全面介绍\n\nJava 是由 Sun Microsystems（后被 Oracle 收购）于 1995 年推出的**面向对象、跨平台**的高级编程语言，由詹姆斯・高斯林（James Gosling）领衔开发，核心设计理念是 “Write Once, Run Anywhere（一次编写，到处运行）”，现已成为全球最主流的编程语言之一，广泛应用于企业级开发、移动开发、大数据、云计算等领域。\n\n## 核心定位\n\nJava 并非单一的 “编程语言”，而是一套完整的**技术生态**：\n\n- 包含编程语言规范、编译器（javac）、虚拟机（JVM）、类库（Java SE API）、开发工具（JDK）等；\n- 核心目标是实现 “跨平台” 和 “高可靠性”，兼顾开发效率与运行性能；\n- 既支持面向对象编程（OOP），也逐步兼容函数式编程（Java 8 引入 Lambda 表达式）。\n\n## 核心特性\n\n### 跨平台性（Write Once, Run Anywhere）\n\n这是 Java 最核心的特性，底层依赖 **Java 虚拟机（JVM）** 实现：\n\n- 开发者编写的 Java 代码（.java 文件）经编译器编译为**字节码文件（.class）**，而非直接编译为机器码；\n- 不同操作系统（Windows、Linux、macOS）安装对应的 JVM，JVM 负责将字节码解释 / 编译为本地机器码执行；\n- 无需针对不同系统修改代码，仅需保证目标系统有兼容的 JVM。\n\n### 面向对象（OOP）\n\nJava 严格遵循面向对象的核心思想，万物皆为 “对象”：\n\n- 封装（Encapsulation）：通过类和访问修饰符（public/private/protected）隐藏内部实现，暴露统一接口；\n- 继承（Inheritance）：通过 `extends` 实现类的复用，单继承（类）+ 多实现（接口）避免复杂继承链；\n- 多态（Polymorphism）：通过方法重写（Override）和接口实现，实现 “一个接口，多种实现”；\n- 核心关键字：`class`、`object`、`interface`、`extends`、`implements` 等。\n\n### 健壮性（Robustness）\n\nJava 设计上大幅降低出错概率，适合构建稳定的企业级应用：\n\n- 自动内存管理（垃圾回收 GC）：JVM 自动回收不再使用的内存，避免 C/C++ 中的内存泄漏、野指针问题；\n- 强类型检查：编译期严格检查类型匹配，减少运行时错误；\n- 异常处理机制：通过 `try-catch-finally` 统一处理错误，避免程序崩溃；\n- 无指针直接操作：通过引用替代指针，降低内存操作风险。\n\n### 安全性（Security）\n\nJava 最初为嵌入式设备和网络环境设计，内置多层安全防护：\n\n- 字节码验证：JVM 加载字节码时验证合法性，防止恶意代码执行；\n- 安全管理器（SecurityManager）：可限制程序的文件访问、网络连接等权限；\n- 沙箱机制：隔离不可信代码的运行环境，避免对系统造成破坏；\n- 适合开发网络应用（如电商、金融），满足数据安全要求。\n\n### 高性能（High Performance）\n\n早期 Java 因 “解释执行” 性能较弱，现已通过多项优化大幅提升：\n\n- JIT 编译器（即时编译）：JVM 运行时将高频执行的字节码编译为本地机器码，接近原生程序性能；\n- 垃圾回收优化：G1、ZGC、Shenandoah 等新一代 GC 算法，大幅降低停顿时间；\n- 支持多线程：内置线程 API（`Thread`、`Runnable`、`Callable`），充分利用多核 CPU；\n- 大数据 / 高并发场景下（如电商秒杀），Java 性能可满足生产要求。\n\n### 可移植性 & 可扩展性\n\n- 可移植性：除跨平台外，Java 类库（如 java.lang、java.util）在不同 JVM 实现中行为一致；\n- 可扩展性：通过接口、抽象类、模块化（Java 9 引入 Module）实现代码解耦，便于扩展和维护；\n- 支持分布式：内置网络编程 API（[java.net](https://java.net/)、java.nio），适配分布式系统开发。\n","tags":["java","技术"],"categories":["java"]},{"title":"局域网即时通讯软件","url":"/2025/01/26/lan-chat-system/","content":"\n\n\n# 基于 JavaSE+Socket 实现局域网即时通讯软件\n\n## 项目背景与需求\n\n在学习 Java 网络编程（Socket）和 Swing GUI 开发后，为了巩固核心知识点并理解 C/S（客户端 / 服务端）架构的通信原理，我设计并开发了这款局域网即时通讯软件。\n\n**核心需求如下：**\n\n1. **极简登录**：用户仅需输入昵称即可进入聊天室，无需复杂的账号密码验证。\n2. **群聊功能**：支持多用户实时群聊，消息需即时推送到所有在线客户端。\n3. **在线状态**：实时展示在线用户列表及人数，用户上下线时自动更新列表。\n4. **界面友好**：基于 Swing 实现可视化操作界面，包含消息展示区、输入区、发送按钮及在线列表区。\n\n## 技术选型与核心思路\n\n### 技术栈\n\n- **GUI 编程**：Swing（实现客户端可视化界面）。\n- **网络编程**：Socket + ServerSocket（基于 TCP 协议实现客户端与服务端的可靠通信）。\n- **数据存储**：HashMap（服务端用于维护在线用户与 Socket 的映射关系）。\n- **多线程**：独立线程处理客户端连接与消息读写，避免单线程阻塞导致的程序假死。\n- **协议设计**：自定义消息类型协议（区分登录、群聊、私聊消息）。\n\n### 整体架构\n\n系统采用标准的 C/S 架构，核心交互流程如下：\n\n1. **服务端**：监听端口 -> 接收客户端连接 -> 分配独立线程处理 -> 维护在线用户列表 -> 转发群聊消息。\n2. **客户端**：登录界面输入昵称 -> 建立 Socket 连接 -> 发送登录消息 -> 进入聊天界面 -> 实时接收服务端推送的在线列表 / 群聊消息。\n\n## 核心功能实现\n\n### 服务端开发\n\n#### 服务端启动与连接监听\n\n服务端的核心职责是监听指定端口，并为每个新连接的客户端分配一个独立的线程（`ServerReaderThread`）。这样可以避免单线程阻塞，支持多客户端并发通信。\n\n```java\npublic class Server {\n    // 存储在线客户端：key为Socket对象，value为用户昵称\n    public static final Map<Socket, String> onLineSockets = new HashMap<>();\n    private static final int PORT = 8888; // 监听端口\n\n    public static void main(String[] args) {\n        System.out.println(\"启动服务端系统.....\");\n        try {\n            ServerSocket serverSocket = new ServerSocket(PORT);\n            // 主线程循环接收客户端连接\n            while (true) {\n                System.out.println(\"等待客户端的连接.....\");\n                Socket socket = serverSocket.accept();\n                // 为每个客户端分配独立线程处理消息交互\n                new ServerReaderThread(socket).start();\n                System.out.println(\"一个客户端连接成功.....\");\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### 消息处理线程（核心逻辑）\n\n服务端线程负责循环读取客户端发送的数据流，根据自定义的协议类型（1 - 登录，2 - 群聊）执行不同的业务逻辑：\n\n- **登录消息**：将用户 Socket 和昵称存入 Map，并广播更新所有客户端的在线列表。\n- **群聊消息**：接收消息内容，拼装成 “昵称 + 时间 + 内容” 的格式，转发给所有在线客户端。\n\n```java\npublic class ServerReaderThread extends Thread {\n    private Socket socket;\n\n    public ServerReaderThread(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            DataInputStream dis = new DataInputStream(socket.getInputStream());\n            while (true) {\n                // 读取消息类型\n                int type = dis.readInt(); \n                switch (type) {\n                    case 1:\n                        // 1. 处理登录逻辑\n                        String nickname = dis.readUTF();\n                        Server.onLineSockets.put(socket, nickname);\n                        updateClientOnLineUserList(); // 广播在线列表\n                        break;\n                    case 2:\n                        // 2. 处理群聊消息转发\n                        String msg = dis.readUTF();\n                        sendMsgToAll(msg); // 群发消息\n                        break;\n                }\n            }\n        } catch (Exception e) {\n            // 客户端下线处理\n            System.out.println(\"客户端下线：\" + socket.getInetAddress().getHostAddress());\n            Server.onLineSockets.remove(socket);\n            updateClientOnLineUserList();\n        }\n    }\n\n    // 广播在线用户列表\n    private void updateClientOnLineUserList() {\n        Collection<String> names = Server.onLineSockets.values();\n        for (Socket s : Server.onLineSockets.keySet()) {\n            try {\n                DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n                dos.writeInt(1); // 标记为列表更新\n                dos.writeInt(names.size());\n                for (String name : names) dos.writeUTF(name);\n                dos.flush();\n            } catch (Exception e) { e.printStackTrace(); }\n        }\n    }\n\n    // 群发消息\n    private void sendMsgToAll(String msg) {\n        String sender = Server.onLineSockets.get(socket);\n        String time = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"HH:mm:ss\"));\n        String sendContent = sender + \" [\" + time + \"]：\\n\" + msg + \"\\n\";\n\n        for (Socket s : Server.onLineSockets.keySet()) {\n            try {\n                DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n                dos.writeInt(2); // 标记为群聊消息\n                dos.writeUTF(sendContent);\n                dos.flush();\n            } catch (Exception e) { e.printStackTrace(); }\n        }\n    }\n}\n```\n\n### 客户端开发\n\n#### 登录与连接\n\n基于 Swing 实现登录界面，用户点击 “进入” 后，程序尝试与服务端建立 Socket 连接，并发送登录协议头（1）和昵称。\n\n```java\n// 登录按钮点击事件逻辑\nenterButton.addActionListener(e -> {\n    String nickname = nicknameField.getText().trim();\n    if (nickname.isEmpty()) return;\n    try {\n        // 建立连接\n        Socket socket = new Socket(\"127.0.0.1\", 8888);\n        // 发送登录信息\n        DataOutputStream dos = new DataOutputStream(socket.getOutputStream());\n        dos.writeInt(1); // 协议头：登录\n        dos.writeUTF(nickname);\n        dos.flush();\n        \n        // 关闭登录窗，打开聊天窗\n        dispose();\n        new ClientChatFrame(socket, nickname).setVisible(true);\n    } catch (IOException ex) {\n        JOptionPane.showMessageDialog(this, \"服务端连接失败！\");\n    }\n});\n```\n\n#### 聊天界面与消息接收\n\n聊天界面包含消息展示区（只读）、输入区和在线列表。为了防止接收消息阻塞 UI 线程，客户端同样启动了一个独立的 `ClientReaderThread` 来专门读取服务端的推送数据。\n\n```java\n// 客户端消息读取线程\nclass ClientReaderThread extends Thread {\n    private Socket socket;\n    private ClientChatFrame frame;\n\n    public ClientReaderThread(ClientChatFrame frame, Socket socket) {\n        this.frame = frame;\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            DataInputStream dis = new DataInputStream(socket.getInputStream());\n            while (true) {\n                int type = dis.readInt();\n                if (type == 1) {\n                    // 更新在线列表UI\n                    int size = dis.readInt();\n                    String[] users = new String[size];\n                    for (int i = 0; i < size; i++) users[i] = dis.readUTF();\n                    frame.onLineUsers.setListData(users);\n                } else if (type == 2) {\n                    // 追加群聊消息到文本域\n                    String msg = dis.readUTF();\n                    frame.smsContent.append(msg);\n                }\n            }\n        } catch (Exception e) {\n            JOptionPane.showMessageDialog(frame, \"您已下线！\");\n        }\n    }\n}\n```\n\n## 项目总结与扩展\n\n### 核心收获\n\n通过本次实战，我深入理解了以下核心概念：\n\n1. **TCP 通信机制**：理解了三次握手、Socket 流的阻塞特性以及如何通过 `DataInputStream/DataOutputStream` 进行结构化数据传输。\n2. **并发编程**：掌握了多线程在网络编程中的应用，特别是服务端如何利用线程池（或简单的多线程）处理高并发连接。\n3. **协议设计**：学会了在传输层之上定义简单的应用层协议（通过 int 类型区分消息体），这是构建复杂网络应用的基础。\n\n### 扩展方向\n\n目前的版本实现了基础的群聊功能，未来可以扩展以下功能：\n\n- **私聊功能**：在协议中增加私聊标记（type 3），并在服务端根据目标用户名查找对应的 Socket 进行发送。\n- **断线重连**：增加心跳检测机制，当检测到连接断开时自动尝试重连。\n- **消息持久化**：将聊天记录保存到本地文件或数据库中，支持历史记录回溯。","tags":["java","项目","技术"],"categories":["java"]},{"title":"leetcodeHot100","url":"/2024/05/23/leetcodehot/","content":"\n\n\n# Hot100\n\n## 动态规划\n\n### 单词拆分\n\n给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。\n\n**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n\n \n\n**示例 1：**\n\n```\n输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n输出: true\n解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。\n```\n\n**示例 2：**\n\n```\n输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\n输出: true\n解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。\n     注意，你可以重复使用字典中的单词。\n```\n\n**示例 3：**\n\n```\n输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\n输出: false\n```\n\n \n\n**提示：**\n\n- `1 <= s.length <= 300`\n- `1 <= wordDict.length <= 1000`\n- `1 <= wordDict[i].length <= 20`\n- `s` 和 `wordDict[i]` 仅由小写英文字母组成\n- `wordDict` 中的所有字符串 **互不相同**\n\n```java\npublic class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        Set<String> wordDictSet = new HashSet(wordDict);\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[0] = true;\n        for (int i = 1; i <= s.length(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && wordDictSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        return dp[s.length()];\n    }\n}\n\n```\n\n外层循环判断到以第i个字母结尾能否成功拼接，内层循环利用哈希contains来遍历判断是否能够拼接并更新dp[i]。\n\n### 最长递增子序列\n\n给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。\n\n**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。\n\n**示例 1：**\n\n```\n输入：nums = [10,9,2,5,3,7,101,18]\n输出：4\n解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [0,1,0,3,2,3]\n输出：4\n```\n\n**示例 3：**\n\n```\n输入：nums = [7,7,7,7,7,7,7]\n输出：1\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 2500`\n- `-104 <= nums[i] <= 104`\n\n\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if(nums.length==0){\n            return 0;\n        }\n        int max=1;\n        int[] dp=new int[nums.length];//dp[i]表示以下标为i为结尾的最长上升序列\n        for(int i=0;i<nums.length;i++){\n            dp[i]=1;\n            for(int j=0;j<i;j++){\n                if(nums[i]>nums[j]){\n                    dp[i]=Math.max(dp[i],dp[j]+1);\n                }\n            }\n            max=Math.max(max,dp[i]);\n\n        }\n        return max;\n    \n    }\n\n}\n```\n\n两层循环，外层记录以dp[i]为结尾的最长上升序列，内层循环遍历前面的dp数组动态改变dp[i]。\n\n\n\n### 乘积最大子数组\n\n给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。\n\n测试用例的答案是一个 **32-位** 整数。\n\n**请注意**，一个只包含一个元素的数组的乘积是这个元素的值。\n\n \n\n**示例 1:**\n\n```\n输入: nums = [2,3,-2,4]\n输出: 6\n解释: 子数组 [2,3] 有最大乘积 6。\n```\n\n**示例 2:**\n\n```\n输入: nums = [-2,0,-1]\n输出: 0\n解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。\n```\n\n \n\n**提示:**\n\n- `1 <= nums.length <= 2 * 104`\n- `-10 <= nums[i] <= 10`\n- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int length = nums.length;\n        long[] maxF = new long[length];\n        long[] minF = new long[length];\n        for (int i = 0; i < length; i++) {\n            maxF[i] = nums[i];\n            minF[i] = nums[i];\n        }\n        for (int i = 1; i < length; ++i) {\n            maxF[i] = Math.max(maxF[i - 1] * nums[i], Math.max(nums[i], minF[i - 1] * nums[i]));\n            minF[i] = Math.min(minF[i - 1] * nums[i], Math.min(nums[i], maxF[i - 1] * nums[i]));\n            if (minF[i] < (-1 << 31)) {\n                minF[i] = nums[i];\n            }\n        }\n        int ans = (int) maxF[0];\n        for (int i = 1; i < length; ++i) {\n            ans = Math.max(ans, (int) maxF[i]);\n        }\n        return ans;\n    }\n}\n\n```\n\n1. **为什么需要同时维护 maxF 和 minF？**\n\n   数组中可能包含负数，当遇到负数时，之前的最小乘积（可能是负数）乘以当前负数，结果会变成正数，反而可能成为新的最大乘积。例如：数组 `[2, -3, -4]`，当遍历到 `-4` 时，`minF[1] = -6`（2*-3），`-6 * -4 = 24` 就是当前的最大乘积。\n\n   \n\n2. **为什么用 long 类型？**\n\n   int 类型的取值范围是 `-2^31` 到 `2^31-1`，多个大数相乘时容易溢出，使用 long 可以临时存储更大的数值，最后再转换回 int，避免计算过程中丢失精度。\n\n   \n\n3. **溢出处理的作用？**\n\n   `(-1 << 31)` 等价于 `Integer.MIN_VALUE`（即 - 2147483648），当 minF [i] 的计算结果小于这个值时，说明已经溢出 int 的最小值范围，此时重置为当前数，避免后续计算出错。\n\n\n### 分割等和子集\n\n给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,5,11,5]\n输出：true\n解释：数组可以分割成 [1, 5, 5] 和 [11] 。\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,5]\n输出：false\n解释：数组不能分割成两个元素和相等的子集。\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 200`\n- `1 <= nums[i] <= 100`\n\n```java\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int n = nums.length;\n        if (n < 2) {\n            return false;\n        }\n        int sum = 0, maxNum = 0;\n        for (int num : nums) {\n            sum += num;\n            maxNum = Math.max(maxNum, num);\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n        int target = sum / 2;\n        if (maxNum > target) {\n            return false;\n        }\n        boolean[][] dp = new boolean[n][target + 1];\n        for (int i = 0; i < n; i++) {\n            dp[i][0] = true;\n        }\n        dp[0][nums[0]] = true;\n        for (int i = 1; i < n; i++) {\n            int num = nums[i];\n            for (int j = 1; j <= target; j++) {\n                if (j >= num) {\n                    dp[i][j] = dp[i - 1][j] | dp[i - 1][j - num];\n                } else {\n                    dp[i][j] = dp[i - 1][j];\n                }\n            }\n        }\n        return dp[n - 1][target];\n    }\n}\n\n```\n\n创建二维数组 dp，包含 n 行 target+1 列，其中 dp[i][j] 表示从数组的 [0,i] 下标范围内选取若干个正整数（可以是 0 个），是否存在一种选取方案使得被选取的正整数的和等于 j。初始时，dp 中的全部元素都是 false。\n\n在定义状态之后，需要考虑边界情况。以下两种情况都属于边界情况。\n\n如果不选取任何正整数，则被选取的正整数之和等于 0。因此对于所有 0≤i<n，都有 dp[i][0]=true。\n\n当 i==0 时，只有一个正整数 nums[0] 可以被选取，因此 dp[0][nums[0]]=true。\n\n对于 i>0 且 j>0 的情况，如何确定 dp[i][j] 的值？需要分别考虑以下两种情况。\n\n如果 j≥nums[i]，则对于当前的数字 nums[i]，可以选取也可以不选取，两种情况只要有一个为 true，就有 dp[i][j]=true。\n\n如果不选取 nums[i]，则 dp[i][j]=dp[i−1][j]；\n如果选取 nums[i]，则 dp[i][j]=dp[i−1][j−nums[i]]。\n如果 j<nums[i]，则在选取的数字的和等于 j 的情况下无法选取当前的数字 nums[i]，因此有 dp[i][j]=dp[i−1][j]。\n\n状态转移方程如下：\n\ndp[i][j]={ \ndp[i−1][j] ∣ dp[i−1][j−nums[i]],  j≥nums[i]\ndp[i−1][j],  j<nums[i]\n\n最终得到 dp[n−1][target] 即为答案。\n\n### 最长有效括号\n\n给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。\n\n左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 `\"(()())\"`。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"(()\"\n输出：2\n解释：最长有效括号子串是 \"()\"\n```\n\n**示例 2：**\n\n```\n输入：s = \")()())\"\n输出：4\n解释：最长有效括号子串是 \"()()\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"\"\n输出：0\n```\n\n \n\n**提示：**\n\n- `0 <= s.length <= 3 * 104`\n- `s[i]` 为 `'('` 或 `')'`\n\n```java\nclass Solution {\n    public int longestValidParentheses(String s) {\n        int maxans = 0;\n        Stack<Integer> stack = new Stack<>();\n        stack.push(-1);\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxans = Math.max(maxans, i - stack.peek());\n                }\n            }\n            \n        }\n        \n        return maxans;\n    }\n}\n\n```\n\n**遇到左括号 `(`**：直接将当前索引 `i` 压入栈。\n\n目的：记录左括号的位置，等待后续右括号来匹配。\n\n**遇到右括号 `)`**：\n\n① 先执行 `stack.pop()`：\n\n- 如果栈顶是左括号的索引（比如 `(` 在 0 位），弹出后栈顶会回到基准位置（-1），此时可以计算有效长度。\n\n- 如果栈顶是基准位置（比如连续 \n\n  ```\n  ))\n  ```\n\n  ），弹出后栈为空，需要把当前索引压入作为新基准。\n\n  \n\n  ② 栈空判断：\n\n- 栈空 → 说明当前右括号无法匹配，把当前索引 `i` 压入栈，作为新的「无效基准」。\n\n- 栈非空 → 用当前索引 `i` 减去栈顶值，得到**以当前右括号结尾的有效括号长度**，并更新最大值 `maxans`。\n\n## 多维动态规划\n\n### 最小路径和\n\n给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)\n\n```\n输入：grid = [[1,3,1],[1,5,1],[4,2,1]]\n输出：7\n解释：因为路径 1→3→1→1→1 的总和最小。\n```\n\n**示例 2：**\n\n```\n输入：grid = [[1,2,3],[4,5,6]]\n输出：12\n```\n\n \n\n**提示：**\n\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 200`\n- `0 <= grid[i][j] <= 200`\n\n```java\n\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        int x=grid.length;\n        int y=grid[0].length;\n        int[][] dp=new int[x][y];\n        dp[0][0]=grid[0][0];\n        for(int i=1;i<x;i++){\n            dp[i][0]=dp[i-1][0]+grid[i][0];\n        }\n        for(int j=1;j<y;j++){\n            dp[0][j]=dp[0][j-1]+grid[0][j];\n        }\n        for(int i=1;i<x;i++){\n            for(int j=1;j<y;j++){\n                dp[i][j]=Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];\n            }\n        }\n        return dp[x-1][y-1];\n\n    }\n}\n```\n\n先初始化dp数组的第一行第一列，后续当前块最小值都是取min（当前块上边，当前块左边）+当前块。\n\n### 不同路径\n\n一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n\n问总共有多少条不同的路径？\n\n \n\n**示例 1：**\n\n![img](https://pic.leetcode.cn/1697422740-adxmsI-image.png)\n\n```\n输入：m = 3, n = 7\n输出：28\n```\n\n**示例 2：**\n\n```\n输入：m = 3, n = 2\n输出：3\n解释：\n从左上角开始，总共有 3 条路径可以到达右下角。\n1. 向右 -> 向下 -> 向下\n2. 向下 -> 向下 -> 向右\n3. 向下 -> 向右 -> 向下\n```\n\n**示例 3：**\n\n```\n输入：m = 7, n = 3\n输出：28\n```\n\n**示例 4：**\n\n```\n输入：m = 3, n = 3\n输出：6\n```\n\n \n\n**提示：**\n\n- `1 <= m, n <= 100`\n- 题目数据保证答案小于等于 `2 * 109`\n\n```java\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp=new int[m][n];\n        for(int i=0;i<m;i++){\n            dp[i][0]=1;\n        }\n        for(int j=0;j<n;j++){\n            dp[0][j]=1;\n        }\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                dp[i][j]=dp[i-1][j]+dp[i][j-1];\n            }\n        }\n        return dp[m-1][n-1];\n\n    }\n}\n```\n\n与最小路径和类似，不做过多解释。\n\n### 最长回文子串\n\n给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。\n\n \n\n**示例 1：**\n\n```\n输入：s = \"babad\"\n输出：\"bab\"\n解释：\"aba\" 同样是符合题意的答案。\n```\n\n**示例 2：**\n\n```\n输入：s = \"cbbd\"\n输出：\"bb\"\n```\n\n \n\n**提示：**\n\n- `1 <= s.length <= 1000`\n- `s` 仅由数字和英文字母组成\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() < 2) {\n            return s;\n        }\n        int maxLen = 1;\n        int start = 0;\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n\n        // 单个字符都是回文\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n\n        // 检查长度为2的子串\n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                maxLen = 2;\n                start = i;\n            }\n        }\n\n        // 检查长度大于2的子串\n        for (int len = 3; len <= n; len++) {  // len是子串长度\n            for (int i = 0; i <= n - len; i++) {  // i是起始索引\n                int j = i + len - 1;  // j是结束索引\n\n                // 如果首尾字符相等且中间子串是回文，则当前子串是回文\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n\n                    // 更新最长回文串信息\n                    if (len > maxLen) {\n                        maxLen = len;\n                        start = i;\n                    }\n                }\n            }\n        }\n\n        return s.substring(start, start + maxLen);\n    }\n}\n```\n\n判断一个字符串是否为回文字符串，需要根据首尾相同+中间部分是回文串就行了。\n\n### 最长公共子序列\n\n给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。\n\n一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。\n\n- 例如，`\"ace\"` 是 `\"abcde\"` 的子序列，但 `\"aec\"` 不是 `\"abcde\"` 的子序列。\n\n两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。\n\n \n\n**示例 1：**\n\n```\n输入：text1 = \"abcde\", text2 = \"ace\" \n输出：3  \n解释：最长公共子序列是 \"ace\" ，它的长度为 3 。\n```\n\n**示例 2：**\n\n```\n输入：text1 = \"abc\", text2 = \"abc\"\n输出：3\n解释：最长公共子序列是 \"abc\" ，它的长度为 3 。\n```\n\n**示例 3：**\n\n```\n输入：text1 = \"abc\", text2 = \"def\"\n输出：0\n解释：两个字符串没有公共子序列，返回 0 。\n```\n\n \n\n**提示：**\n\n- `1 <= text1.length, text2.length <= 1000`\n- `text1` 和 `text2` 仅由小写英文字符组成。\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int m = text1.length(), n = text2.length();\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = 1; i <= m; i++) {\n            char c1 = text1.charAt(i - 1);\n            for (int j = 1; j <= n; j++) {\n                char c2 = text2.charAt(j - 1);\n                if (c1 == c2) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n        return dp[m][n];\n    }\n}\n\n```\n\n核心在于：dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n\n如果字符不相等，取「不考虑text1当前字符」或「不考虑text2当前字符」的最大值。\n\n### 编辑距离\n\n给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。\n\n你可以对一个单词进行如下三种操作：\n\n- 插入一个字符\n- 删除一个字符\n- 替换一个字符\n\n \n\n**示例 1：**\n\n```\n输入：word1 = \"horse\", word2 = \"ros\"\n输出：3\n解释：\nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**示例 2：**\n\n```\n输入：word1 = \"intention\", word2 = \"execution\"\n输出：5\n解释：\nintention -> inention (删除 't')\ninention -> enention (将 'i' 替换为 'e')\nenention -> exention (将 'n' 替换为 'x')\nexention -> exection (将 'n' 替换为 'c')\nexection -> execution (插入 'u')\n```\n\n \n\n**提示：**\n\n- `0 <= word1.length, word2.length <= 500`\n- `word1` 和 `word2` 由小写英文字母组成\n\n```java\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        int n = word1.length();\n        int m = word2.length();\n\n        // 有一个字符串为空串\n        if (n * m == 0) {\n            return n + m;\n        }\n\n        // DP 数组\n        int[][] D = new int[n + 1][m + 1];\n\n        // 边界状态初始化\n        for (int i = 0; i < n + 1; i++) {\n            D[i][0] = i;\n        }\n        for (int j = 0; j < m + 1; j++) {\n            D[0][j] = j;\n        }\n\n        // 计算所有 DP 值\n        for (int i = 1; i < n + 1; i++) {\n            for (int j = 1; j < m + 1; j++) {\n                int left = D[i - 1][j] + 1;\n                int down = D[i][j - 1] + 1;\n                int left_down = D[i - 1][j - 1];\n                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {\n                    left_down += 1;\n                }\n                D[i][j] = Math.min(left, Math.min(down, left_down));\n            }\n        }\n        return D[n][m];\n    }\n}\n\n```\n\n状态转移的三种核心操作：\n\n1. **删除**：`left = D[i-1][j] + 1` → 删除 `word1` 的第 `i` 个字符，等价于先把 `word1` 前 `i-1` 个字符转成 `word2` 前 `j` 个字符，再删 1 次。\n2. **插入**：`down = D[i][j-1] + 1` → 向 `word1` 插入 `word2` 的第 `j` 个字符，等价于先把 `word1` 前 `i` 个字符转成 `word2` 前 `j-1` 个字符，再插 1 次。\n3. **替换 / 匹配**：`left_down` → 若 `word1[i-1] == word2[j-1]`，无需操作；若不等，替换 `word1[i-1]` 为 `word2[j-1]`，加 1 次操作。\n\n状态转移：每一步从**删除、插入、替换**三种操作中选代价最小的，字符相等时替换操作无需额外代价。\n\n## 技巧\n\n### 只出现一次的数字\n\n给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n\n你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。\n\n \n\n**示例 1 ：**\n\n**输入：**nums = [2,2,1]\n\n**输出：**1\n\n**示例 2 ：**\n\n**输入：**nums = [4,1,2,1,2]\n\n**输出：**4\n\n**示例 3 ：**\n\n**输入：**nums = [1]\n\n**输出：**1\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 3 * 104`\n- `-3 * 104 <= nums[i] <= 3 * 104`\n- 除了某个元素只出现一次以外，其余每个元素均出现两次。\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int sum=0;\n        for(int i=0;i<nums.length;i++){\n            sum^=nums[i];\n        }\n        return sum;\n    }\n}\n```\n\n采用异或方式，相同数异或为0，0与a异或结尾2为a。且满足交换律\n\n### 多数元素\n\n给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。\n\n你可以假设数组是非空的，并且给定的数组总是存在多数元素。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [3,2,3]\n输出：3\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,2,1,1,1,2,2]\n输出：2\n```\n\n \n\n**提示：**\n\n- `n == nums.length`\n- `1 <= n <= 5 * 104`\n- `-109 <= nums[i] <= 109`\n- 输入保证数组中一定有一个多数元素。\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length / 2];\n    }\n}\n\n```\n\n### 颜色分类\n\n给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。\n\n我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。\n\n必须在不使用库内置的 sort 函数的情况下解决这个问题。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [2,0,2,1,1,0]\n输出：[0,0,1,1,2,2]\n```\n\n**示例 2：**\n\n```\n输入：nums = [2,0,1]\n输出：[0,1,2]\n```\n\n \n\n**提示：**\n\n- `n == nums.length`\n- `1 <= n <= 300`\n- `nums[i]` 为 `0`、`1` 或 `2`\n\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        int n = nums.length;\n        int p0 = 0, p2 = n - 1;\n        for (int i = 0; i <= p2; ++i) {\n            while (i <= p2 && nums[i] == 2) {\n                int temp = nums[i];\n                nums[i] = nums[p2];\n                nums[p2] = temp;\n                --p2;\n            }\n            if (nums[i] == 0) {\n                int temp = nums[i];\n                nums[i] = nums[p0];\n                nums[p0] = temp;\n                ++p0;\n            }\n        }\n    }\n}\n\n```\n\n把2移到最右边，0移到最左边\n\n### 下一个排列\n\n整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。\n\n- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。\n\n整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。\n\n- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。\n- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。\n- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。\n\n给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。\n\n必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3]\n输出：[1,3,2]\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,2,1]\n输出：[1,2,3]\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,1,5]\n输出：[1,5,1]\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 100`\n- `0 <= nums[i] <= 100`\n\n```\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (j >= 0 && nums[i] >= nums[j]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    public void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    public void reverse(int[] nums, int start) {\n        int left = start, right = nums.length - 1;\n        while (left < right) {\n            swap(nums, left, right);\n            left++;\n            right--;\n        }\n    }\n}\n\n```\n\n思路及解法\n\n注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：\n\n我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。\n\n同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。\n\n以排列 [4,5,2,6,3,1] 为例：\n\n我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。\n\n当我们完成交换后排列变为 [4,5,3,6,2,1]，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6]。\n\n具体地，我们这样描述该算法，对于长度为 n 的排列 a：\n\n首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]<a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。\n\n如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]<a[j]。这样「较大数」即为 a[j]。\n\n交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。\n\n### 寻找重复数\n\n给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。\n\n假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。\n\n你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,3,4,2,2]\n输出：2\n```\n\n**示例 2：**\n\n```\n输入：nums = [3,1,3,4,2]\n输出：3\n```\n\n**示例 3 :**\n\n```\n输入：nums = [3,3,3,3,3]\n输出：3\n```\n\n \n\n \n\n**提示：**\n\n- `1 <= n <= 105`\n- `nums.length == n + 1`\n- `1 <= nums[i] <= n`\n- `nums` 中 **只有一个整数** 出现 **两次或多次** ，其余整数均只出现 **一次**\n\n```java\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = nums[0];\n        int fast = nums[0];\n        do {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        } while (slow != fast);\n        int find = nums[0];\n        while (slow != find) {\n            slow = nums[slow];\n            find = nums[find];\n        }\n        return find;\n    }\n}\n```\n\n这是一个检测链表是否有环的算法，正好符合题意。\n","tags":["leetcode","代码"],"categories":["leetcode"]},{"title":"Hello World","url":"/2013/12/24/hello-world/","content":"\nWelcome to [Hexo](http://zespia.tw/hexo)! This is your very first post. Check [documentation](http://zespia.tw/hexo/docs) to learn how to use.\n"}]