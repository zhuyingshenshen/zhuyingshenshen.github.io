[{"title":"技术栏","url":"/2025/12/09/技术栏/","content":"\n# 测试1\n\n测试一下\n\n## 哈哈哈\n\n1234\n\n# 测试2\n\n## 哈哈哈\n\n12345","tags":["web","Lua"],"categories":["技术"]},{"title":"Spintboot介绍","url":"/2025/07/11/springboot/","content":"\n# SpringBoot 全面介绍\n\nSpringBoot 是由 Pivotal 团队（后归属于 VMware）基于 Spring 框架推出的**轻量级、约定优于配置**的开源框架，核心目标是**简化 Spring 应用的开发、配置、部署和运维**，让开发者能够快速搭建生产级别的 Spring 应用。\n\n## 核心定位\n\nSpringBoot 并非替代 Spring，而是对 Spring 框架的**封装和增强**：\n\n- 解决 Spring 原生开发中 “配置繁琐、依赖管理复杂、部署麻烦” 等痛点；\n- 提供 “开箱即用” 的能力，同时保留足够的灵活性（支持自定义配置）；\n- 专注于快速构建独立的、可运行的 Spring 应用（尤其是微服务场景）。\n\n## 核心特性\n\n### 约定优于配置（Convention over Configuration）\n\nSpringBoot 内置了大量默认配置规则，无需手动编写 XML 配置（如 Spring 传统的 `applicationContext.xml`），仅需少量配置（甚至零配置）即可启动应用：\n\n- 默认扫描主程序所在包及其子包的组件；\n- 默认配置数据源、日志、Web 容器（Tomcat）等核心组件；\n- 通过 `application.yml/application.properties` 即可覆盖默认配置。\n\n### 自动配置（AutoConfiguration）\n\n这是 SpringBoot 最核心的特性：\n\n- 基于项目中引入的依赖（如 `spring-boot-starter-web`），自动识别并配置相关组件（如 DispatcherServlet、Tomcat、Jackson 等）；\n- 底层通过 `@EnableAutoConfiguration` 注解结合 SPI（服务提供者接口）机制实现，开发者可通过 `@Conditional` 系列注解自定义自动配置规则；\n- 支持通过 `spring-boot-starter` 依赖 Starter 套件，一键引入场景化依赖（如 Web、数据库、缓存、消息队列等）。\n\n### 起步依赖（Starter Dependencies）\n\n将常用场景的依赖打包成统一的 Starter，避免手动管理依赖版本和依赖冲突：\n\n| 常用 Starter                   | 用途                            |\n| ------------------------------ | ------------------------------- |\n| `spring-boot-starter-web`      | Web 开发（Spring MVC + Tomcat） |\n| `spring-boot-starter-data-jpa` | 持久层（JPA + Hibernate）       |\n| `spring-boot-starter-mybatis`  | 持久层（MyBatis）               |\n| `spring-boot-starter-redis`    | Redis 缓存操作                  |\n| `spring-boot-starter-test`     | 单元测试（JUnit + Mockito）     |\n\n### 嵌入式容器\n\nSpringBoot 内置了 Tomcat（默认）、Jetty、Undertow 等 Servlet 容器，应用可直接打成 **可执行 JAR 包**，无需手动部署到外部容器：\n\n- 执行 `java -jar xxx.jar` 即可启动应用；\n- 支持通过配置修改容器端口、线程池等参数。\n\n### 监控与运维\n\n- 内置 `spring-boot-starter-actuator`，可暴露应用健康状态、指标、日志、环境变量等监控端点（如 `/actuator/health`、`/actuator/metrics`）；\n- 支持与 Prometheus、Grafana 等监控工具集成，实现可视化监控和告警；\n- 支持热部署（`spring-boot-devtools`），开发阶段无需重启应用即可生效代码修改。\n\n### 简化部署\n\n- 支持打包为可执行 JAR/WAR 包，也支持 Docker 容器化部署；\n- 与 CI/CD 工具（Jenkins、GitLab CI）无缝集成，简化持续交付流程。\n\n### 无代码生成 & 无 XML 配置\n\n完全基于注解驱动开发，无需生成额外代码，也无需编写 XML 配置文件，核心配置通过注解（如 `@SpringBootApplication`、`@RestController`）和配置文件实现。","tags":["SpringBoot"],"categories":["java"]},{"title":"java基础","url":"/2025/07/10/Javabasic/","content":"\n## Day1\n\n随便写一个整数，默认是int类型，如果将一个超过int范围的数赋值给一个long类型的变量\n\n`long l1 = 334254235555`则会报错，因为超出了int范围。正确写法是加数后面加上L或l指定类型。\n\n如果是任意写一个浮点数，则默认是double类型的，若要指定为float则加上f\n\nchar既是字符，又能当作数值运算。\n\n## Day2\n在表达式中，小范围类型的变量，会自动转换成表达式中较大范围的类型，再参与运算。\n\nbyte、short、char —> int —>long —>float —> double\n\n+ 表达式的最终结果类型由表达式中的最高类型决定。\n+ 在表达式中，**byte、short、char是直接转换成int类型参与运算的。**\n\n扩展的赋值运算符(+= -= *= /= %=)隐含了强制类型转换\n\n&&和&区别 判断结果一样,&&短路与会提前中断。\n\n||和|区别，判断结果一样，||短路或会提前中断。\n\n## Day3\nSwitch 表达式类型只能是byte、short、int、char,JDK5开始支持枚举，JDK7开始支持String,不支持double、float、long。case给出的值不能重复，且只能是字面量，不能是变量。不要忘写break。\n\n### 数组\n```java\n//静态初始化数组 定义时已确定数据\n数据类型[] 数据名 = {元素1,元素2,元素3,..。};\nint[] arr = {12,24,36};\n//完整格式\n数据类型[] 数据名 = new 数据类型[]{元素1，元素2，元素3...}\nint[] arr = new int[]{12,24,36};\n//动态初始化数组\n数据类型[] 数据名 = new 数据类型[长度]\nint[] arr = new int[3];\n```\n\n## Day4\n类默认就自带了一个无参构造器(类似C++的构造函数)\n\n为类定义了有参数构造器，那么类默认的无参数构造器就没有了，此时如果还想用无参数构造器，就必须手写一个无参数构造器\n\n类的属性前面加static,意为静态变量，类的静态变量是共用的，在内存中占一处空间，一般是用类名.属性名来使用。\n\n类的方法前面加staic,意为静态方法，静态方法可以用来设计工具类，工具类中的方法都是静态方法，每个类方法用来完成一个功能，提高代码复用性。\n\n**静态方法和实例方法的区别:**静态方法可以直接访问静态成员，但不可以访问实例成员(静态成员存储在方法区，在类加载时初始化，与类本身绑定，静态方法本身没有隐含的`this`引用，)\n\n子类对象包含父类的所有成员，因为子类实例化时回调用父类的构造函数初始化父类的成员。虽然私有变量存在于子类对象中，但是子类无法通过变量名直接操作它们(需要通过父类提供的public/protected方法访问)\n\n### 权限修饰符\nprivate 本类\n\ndefault(缺省) 本类、同一个包中的类\n\nprotected 本类，同一个包的类、子孙类中\n\npublic 任意位置\n\n## Day5\n### 重写\n@Override 重写标识符\n\n子类重写Object类的toString()方法(默认返回对象地址)，以便放回对象的内容。\n\n### this()\n默认情况下，子类全部构造器的第一行代码都是super()，它会调用父类的无参数构造器。\n\n如果父类没有无参数构造器，则我们必须要在子类构造器的第一行手写super(...),去指定调用父类的有参构造器。\n\n**super构造器或this构造器必须写在构造器的第一行 并且不能同时出现**\n\n### 多态\n多态前提:有继承/实现关系;存在父类引用子类对象；存在方法重写\n\n```plain\nPeople p1 = new Student();\np1.run();\n\nPeople p2 = new Teacher();\np2.run();\n```\n\nJava多态表现为对象多态、行为多态(方法重写)\n\n多态是对象、行为的多态， 方法:编译看左，左即左边的类 运行看右 成员变量:编译看左，运行也看左 这里的“左”指的是**引用类型**，也就是声明对象时等号左边的类型。\n\n成员变量和方法不同，它们**不具备多态性**。**无论运行时实际对象是什么类型，访问成员变量时，永远只看引用类型（左边）的成员变量。**\n\n多态下不能调子类独有功能 （编译器为了保证代码的安全性，只允许你调用左边引用类型所拥有的功能。)\n\n多态好处:右边对象解耦合，便于拓展维护。定义方法时，使用父类类型形参可以接收一切子类对象，扩展性强\n\n```plain\n遇到的问题:\n\nQ:Animal a1 = new Tortoise();\n\nTortoise t1 = a1;直接这样写为什么不行 a1难道不算Tortoise的对象吗?前面不是刚new了一遍吗\n\nTortoise t1 = (Tortoise) a1; 为什么必须像这样强制转换了才能用?\n\nA:编译器的保护机制，使得开发者必须强制类型转换告诉编译器知道a1是Tortoise类型。\n\nAnimal a1 = new Tortoise();\n\nParrot p1 = (Parrot) a1 这样写编译时不保存，但是运行时会发现试图将Tortoise类型的对象转换成Parrot,会报错ClassCastException。\n```\n\n**Java建议在强制转换前，应该判断对象的真实类型，再进行强制类型转换。**(用instanceof)\n\n## Day6\n### final关键字\nfinal修饰静态变量，这个变量今后被称为常量，常量名称建议全部大写。\n\n被final修饰的量**不能被继承**\n\n修饰基本类型变量，变量存储的**数据**不能被改变。\n\n修饰引用类型变量(数组)，变量存储的**地址**不能被改变，但地址所指对象的内容可变。\n\n### 设计模式\n单例设计模式\n\n```java\n//单例设计模式\npublic class A{\n    private static A a =new A()；\n    //私有化构造器\n    private A(){\n    \n    }\n    public static A getInstance(){\n        return a;\n    }\n}\n//懒汉式单例类 延迟加载对象\npublic class B{\n    private static B b；\n    //私有化构造器\n    private b(){\n    }\n    public static B getInstance(){\n        if(b == null){\n            b = new B();\n        }\n        return b;\n    }\n}\n```\n\n模板方法设计模式\n\n1、定义一个抽象类。\n\n2、在里面定义2个方法\n\n+ 一个是模板方法：把共同的实现步骤放里面去。\n+ 一个是抽象方法：不确定的实现步骤，交给具体的子类来完成。\n\n### 枚举类\n枚举类是final最终类不可被继承，枚举类继承java.lang.Enum类 枚举类第一行只能罗列一些常量名称，**常量回记住枚举类的一个对象。**构造器为私有，对外不能创建对象。编译器为枚举类新增了几个方法。\n\n```java\npublic enum A{\n    X,Y,Z;\n}\nComplied from \"A.java\"\npublic final class A extends java.lang.Enum<A>{\n    public static fianl A X = new A();\n    public static fianl A Y = new A();\n    public static fianl A Z = new A();\n    \n    public static A[] values();\n    public static A valueOf(java.lang.String);\n\n}\n```\n\n### 抽象类\n用abstract修饰；抽象方法只有方法签名，不能写方法体。\n\n可以不写抽象方法，但有**抽象方法的类必须是抽象类**，类有的成员，抽象类都具备。\n\n**抽象类不能创建对象**，仅作为一种特殊的父类让子类继承并实现。**抽象类的子类必须重写父类的所有抽象方法**，除非子类本身也被声明为 `abstract`\n\n### 接口\n使用interface关键字定义的一种结构，JDK8之前，接口中只能定义成员变量(常量)和成员方法(抽象方法)。\n\n`实现类`实现多个接口，必须重写完全部接口的全部抽象方法，否则实现类需要定义成抽象类。\t\n\n修饰符 class 实现类类名 implements 接口1，接口2，接口3， ...{\n\n}\n\n接口在高版本支持默认方法，私有方法private\n\n**注意事项：**\n\n+ 接口与接口可以多继承：一个接口可以同时继承多个接口[重点]\n+ 一个接口继承多个接口，如果多个接口存在方法签名冲突（方法名和参数列表相同但返回类型不同的方法)则此时不支持多继承，也不支持多实现\n+ _一个类继承了父类，又同时实现了接口，如果父类中和接口中有同名的默认方法，实现类会优先用父类的_\n+ 一个类实现了多个接口，如果多个接口中存在同名的方法，可以不冲突，\n\n### 匿名内部类\n书写格式:\n\n```java\nnew 类或接口(参数值...){\n     类体(一般是方法重写);\n}\n\nnew Animal(){\n @Override\n public void cry(){\n }\n};\n```\n\n匿名内部类本质就是一个子类，并会立即创建出一个子类对象。\n\n匿名内部类实际上有名字(在编译后产生类文件)外部类名$编号.class\n\n**匿名类的本质是编译器自动生成一个没有名字的实现类，并直接实例化。**\n\n`public static void start(Swim s)`这里的s可以直接用下面这种方式传参\n\n```java\nstart(new Swim(){\n    @Override\n    pubic void swimming(){\n        System.out.printlin(\"游泳1\");\n    }\n});\n```\n\n使用场景一:为按钮添加事件监听器对象\n\n使用场景二:使用comparator接口的匿名内部类实现对数组排序\n\n### Lambda\nLambda表达式只能简化函数式接口的匿名内部类\n\n```java\n@FunctionalInterface // 声明函数式接口的注解 声明后只能写一个抽象方法\ninterface Swim{\n    void swimming();\n}\n\n/*Swim s1 = new Swim(){\n    @Override\n    public void swimming(){\n        System.out.println(\"学生游泳\");\n    }\n};\n*/\nSwim s1 = () - > {\n    System.out.println(\"学生游泳\");\n};\n\n\n```\n\n\n\n函数式接口:只有一个抽象方法的接口  \n`@FunctionInterface`声明函数式接口的注解\n\n\n\n#### 静态方法引用\n类名::静态方法 使用场景:Lambda表达式只调用**一个**静态方法，并且\"->\"前后参数形式一致，就可以使用静态方法引用。\n\n#### 实例方法引用\n对象名::实例方法 使用场景:如果某个Lambda表达式里只是通过对象名称调用一个实例方法，并且“->”前后参数的形式一致，就可以使用实例方法引用。\n\n#### 特定方法类型引用\n特性类的名称::方法 使用场景:某个lambda表达式中只是调用一个特定类型的实例方法，并且前面参数列表中的第一个参数是作为方法的主调，后面的所有参数都是作为该实例方法的入参的，则此时可以使用特定类型的方法引用。\n\n```java\nArrays.sort(names);\nArrays.sort(names,new Comparator<String>(){\n    @Override\n    public int compare(String o1,String o2){\n        //o1 a1\n        //o2 a2\n        return o1.compareToIgnoreCase(o2);\n    }\n});\nArrays.sort(names,(o1,o2) -> o1.compareToIgnoreCase(o2));\n//特定类型方法引用: 类型名称::方法名\nArrays.sort(names,String::compareToIgnoreCase);\n\nSystem.out.printlin(Arrays.toString(names));\n```\n\n\n\n#### 构造器引用\n类名::new 使用场景:如果某个lambda表达式里只是在创建对象，并且“->”前后参数情况一致，就可以使用构造器引用。\n\n### String\n创建对象封装字符串数据的方式\n\n+ 直接使用双引号“...”(会存储到字符串常量池，并且相同内容的字符串只存储一份)\n+ new String类，调用构造器初始化字符串对象(每new一次都会产生一个新的对象放到堆内存中)\n\n","tags":["java"],"categories":["java"]},{"title":"java介绍","url":"/2025/07/10/java/","content":"\n# Java 全面介绍\n\nJava 是由 Sun Microsystems（后被 Oracle 收购）于 1995 年推出的**面向对象、跨平台**的高级编程语言，由詹姆斯・高斯林（James Gosling）领衔开发，核心设计理念是 “Write Once, Run Anywhere（一次编写，到处运行）”，现已成为全球最主流的编程语言之一，广泛应用于企业级开发、移动开发、大数据、云计算等领域。\n\n## 核心定位\n\nJava 并非单一的 “编程语言”，而是一套完整的**技术生态**：\n\n- 包含编程语言规范、编译器（javac）、虚拟机（JVM）、类库（Java SE API）、开发工具（JDK）等；\n- 核心目标是实现 “跨平台” 和 “高可靠性”，兼顾开发效率与运行性能；\n- 既支持面向对象编程（OOP），也逐步兼容函数式编程（Java 8 引入 Lambda 表达式）。\n\n## 核心特性\n\n### 跨平台性（Write Once, Run Anywhere）\n\n这是 Java 最核心的特性，底层依赖 **Java 虚拟机（JVM）** 实现：\n\n- 开发者编写的 Java 代码（.java 文件）经编译器编译为**字节码文件（.class）**，而非直接编译为机器码；\n- 不同操作系统（Windows、Linux、macOS）安装对应的 JVM，JVM 负责将字节码解释 / 编译为本地机器码执行；\n- 无需针对不同系统修改代码，仅需保证目标系统有兼容的 JVM。\n\n### 面向对象（OOP）\n\nJava 严格遵循面向对象的核心思想，万物皆为 “对象”：\n\n- 封装（Encapsulation）：通过类和访问修饰符（public/private/protected）隐藏内部实现，暴露统一接口；\n- 继承（Inheritance）：通过 `extends` 实现类的复用，单继承（类）+ 多实现（接口）避免复杂继承链；\n- 多态（Polymorphism）：通过方法重写（Override）和接口实现，实现 “一个接口，多种实现”；\n- 核心关键字：`class`、`object`、`interface`、`extends`、`implements` 等。\n\n### 健壮性（Robustness）\n\nJava 设计上大幅降低出错概率，适合构建稳定的企业级应用：\n\n- 自动内存管理（垃圾回收 GC）：JVM 自动回收不再使用的内存，避免 C/C++ 中的内存泄漏、野指针问题；\n- 强类型检查：编译期严格检查类型匹配，减少运行时错误；\n- 异常处理机制：通过 `try-catch-finally` 统一处理错误，避免程序崩溃；\n- 无指针直接操作：通过引用替代指针，降低内存操作风险。\n\n### 安全性（Security）\n\nJava 最初为嵌入式设备和网络环境设计，内置多层安全防护：\n\n- 字节码验证：JVM 加载字节码时验证合法性，防止恶意代码执行；\n- 安全管理器（SecurityManager）：可限制程序的文件访问、网络连接等权限；\n- 沙箱机制：隔离不可信代码的运行环境，避免对系统造成破坏；\n- 适合开发网络应用（如电商、金融），满足数据安全要求。\n\n### 高性能（High Performance）\n\n早期 Java 因 “解释执行” 性能较弱，现已通过多项优化大幅提升：\n\n- JIT 编译器（即时编译）：JVM 运行时将高频执行的字节码编译为本地机器码，接近原生程序性能；\n- 垃圾回收优化：G1、ZGC、Shenandoah 等新一代 GC 算法，大幅降低停顿时间；\n- 支持多线程：内置线程 API（`Thread`、`Runnable`、`Callable`），充分利用多核 CPU；\n- 大数据 / 高并发场景下（如电商秒杀），Java 性能可满足生产要求。\n\n### 可移植性 & 可扩展性\n\n- 可移植性：除跨平台外，Java 类库（如 java.lang、java.util）在不同 JVM 实现中行为一致；\n- 可扩展性：通过接口、抽象类、模块化（Java 9 引入 Module）实现代码解耦，便于扩展和维护；\n- 支持分布式：内置网络编程 API（[java.net](https://java.net/)、java.nio），适配分布式系统开发。\n","tags":["java","技术"],"categories":["java"]},{"title":"Hello World","url":"/2013/12/24/hello-world/","content":"\nWelcome to [Hexo](http://zespia.tw/hexo)! This is your very first post. Check [documentation](http://zespia.tw/hexo/docs) to learn how to use.\n"}]